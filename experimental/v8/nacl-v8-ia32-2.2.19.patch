Index: test/cctest/test-log.cc
===================================================================
--- test/cctest/test-log.cc	(revision 4925)
+++ test/cctest/test-log.cc	(working copy)
@@ -151,7 +151,7 @@
 // positives.  Under other platforms profiling is done via a high-priority
 // thread, so this case never happen.
 static bool was_sigprof_received = true;
-#ifdef __linux__
+#if defined(__linux__) && !defined(NACL)
 
 struct sigaction old_sigprof_handler;
 pthread_t our_thread;
@@ -266,7 +266,7 @@
   const char* code_creation = "\ncode-creation,";  // eq. to /^code-creation,/
   CHECK_NE(NULL, matcher->Find(code_creation));
 
-#ifdef __linux__
+#if defined(__linux__) && !defined(NACL)
   // Intercept SIGPROF handler to make sure that the test process
   // had received it. Under load, system can defer it causing test failure.
   // It is important to execute this after 'ResumeProfiler'.
Index: test/cctest/test-debug.cc
===================================================================
--- test/cctest/test-debug.cc	(revision 4925)
+++ test/cctest/test-debug.cc	(working copy)
@@ -1521,9 +1521,9 @@
   break_point_hit_count = 0;
   ClearBreakPointFromJS(sbp1);
   f->Call(env->Global(), 0, NULL);
-  CHECK_EQ(0, break_point_hit_count);
+  CHECK_EQ((int)0, break_point_hit_count);
   g->Call(env->Global(), 0, NULL);
-  CHECK_EQ(0, break_point_hit_count);
+  CHECK_EQ((int)0, break_point_hit_count);
 
   // Call f and g with break point on line 2.
   int sbp2 = SetScriptBreakPointByIdFromJS(script_id, 2, 0);
@@ -5021,8 +5021,8 @@
 // in the debugger.
 static v8::Handle<v8::Value> CheckFrameCount(const v8::Arguments& args) {
   CHECK(v8::Debug::Call(frame_count)->IsNumber());
-  CHECK_EQ(args[0]->Int32Value(),
-           v8::Debug::Call(frame_count)->Int32Value());
+  CHECK_EQ((int)args[0]->Int32Value(),
+           (int)v8::Debug::Call(frame_count)->Int32Value());
   return v8::Undefined();
 }
 
@@ -5031,8 +5031,8 @@
 // JavaScript function in the debugger.
 static v8::Handle<v8::Value> CheckSourceLine(const v8::Arguments& args) {
   CHECK(v8::Debug::Call(frame_source_line)->IsNumber());
-  CHECK_EQ(args[0]->Int32Value(),
-           v8::Debug::Call(frame_source_line)->Int32Value());
+  CHECK_EQ((int)args[0]->Int32Value(),
+           (int)v8::Debug::Call(frame_source_line)->Int32Value());
   return v8::Undefined();
 }
 
Index: test/cctest/test-regexp.cc
===================================================================
--- test/cctest/test-regexp.cc	(revision 4925)
+++ test/cctest/test-regexp.cc	(working copy)
@@ -1393,8 +1393,8 @@
     unibrow::uchar uncanon[unibrow::Ecma262UnCanonicalize::kMaxWidth];
     int length = un_canonicalize.get(lower, '\0', uncanon);
     CHECK_EQ(2, length);
-    CHECK_EQ(upper, uncanon[0]);
-    CHECK_EQ(lower, uncanon[1]);
+    CHECK_EQ(upper, (int)uncanon[0]);
+    CHECK_EQ(lower, (int)uncanon[1]);
   }
   for (uc32 c = 128; c < (1 << 21); c++)
     CHECK_GE(canonicalize(c), 128);
@@ -1456,7 +1456,7 @@
     unsigned dist = start & CharacterRange::kPayloadMask;
     unibrow::uchar first[unibrow::Ecma262UnCanonicalize::kMaxWidth];
     int first_length = un_canonicalize.get(next_block, '\0', first);
-    for (unsigned i = 1; i < dist; i++) {
+    for (int i = 1; i < (int)dist; i++) {
       CHECK_EQ(i, CanonRange(next_block + i));
       unibrow::uchar succ[unibrow::Ecma262UnCanonicalize::kMaxWidth];
       int succ_length = un_canonicalize.get(next_block + i, '\0', succ);
Index: test/cctest/test-heap-profiler.cc
===================================================================
--- test/cctest/test-heap-profiler.cc	(revision 4925)
+++ test/cctest/test-heap-profiler.cc	(working copy)
@@ -24,7 +24,11 @@
   v8::Script::Compile(v8::String::New(src))->Run();
 }
 
+bool operator== (const JSObjectsCluster& a, const JSObjectsCluster& b) {
+  return memcmp(&a, &b, sizeof(JSObjectsCluster))==0;
+}
 
+
 namespace {
 
 class ConstructorHeapProfileTestHelper : public i::ConstructorHeapProfile {
Index: test/cctest/test-api.cc
===================================================================
--- test/cctest/test-api.cc	(revision 4925)
+++ test/cctest/test-api.cc	(working copy)
@@ -3678,7 +3678,7 @@
   v8::ExtensionConfiguration config(1, bDeps);
   v8::Handle<Context> context = Context::New(&config);
   CHECK(context.IsEmpty());
-  CHECK_NE(last_location, NULL);
+  CHECK_NE(NULL, last_location);
 }
 
 
@@ -8431,7 +8431,7 @@
   v8::ScriptData* sd =
       v8::ScriptData::PreCompile(script, i::StrLength(script));
   CHECK_NE(sd->Length(), 0);
-  CHECK_NE(sd->Data(), NULL);
+  CHECK_NE(sd->Data(), (void*)0);
   CHECK(!sd->HasError());
   delete sd;
 }
Index: test/cctest/test-assembler-ia32.cc
===================================================================
--- test/cctest/test-assembler-ia32.cc	(revision 4925)
+++ test/cctest/test-assembler-ia32.cc	(working copy)
@@ -394,10 +394,10 @@
 #endif
 
   F7 f = FUNCTION_CAST<F7>(Code::cast(code)->entry());
-  CHECK_EQ(kLess, f(1.1, 2.2));
-  CHECK_EQ(kEqual, f(2.2, 2.2));
-  CHECK_EQ(kGreater, f(3.3, 2.2));
-  CHECK_EQ(kNaN, f(OS::nan_value(), 1.1));
+  CHECK_EQ((int)kLess, f(1.1, 2.2));
+  CHECK_EQ((int)kEqual, f(2.2, 2.2));
+  CHECK_EQ((int)kGreater, f(3.3, 2.2));
+  CHECK_EQ((int)kNaN, f(OS::nan_value(), 1.1));
 }
 
 #undef __
Index: test/cctest/test-heap.cc
===================================================================
--- test/cctest/test-heap.cc	(revision 4925)
+++ test/cctest/test-heap.cc	(working copy)
@@ -843,8 +843,8 @@
       Heap::AllocateFixedArray(n_elements));
 
   int index = n_elements - 1;
-  CHECK_EQ(flags_ptr,
-           HeapObject::RawField(array, FixedArray::OffsetOfElementAt(index)));
+  CHECK_EQ((void*)flags_ptr,
+           (void*)HeapObject::RawField(array, FixedArray::OffsetOfElementAt(index)));
   array->set(index, Smi::FromInt(0));
   // This chould have turned next page into LargeObjectPage:
   // CHECK(Page::FromAddress(next_page)->IsLargeObjectPage());
Index: samples/hello.cc
===================================================================
--- samples/hello.cc	(revision 0)
+++ samples/hello.cc	(revision 0)
@@ -0,0 +1,34 @@
+#include <v8.h>
+
+using namespace v8;
+
+int main(int argc, char* argv[]) {
+
+  // Create a stack-allocated handle scope.
+  HandleScope handle_scope;
+
+  // Create a new context.
+  Persistent<Context> context = Context::New();
+
+  // Enter the created context for compiling and
+  // running the hello world script. 
+  Context::Scope context_scope(context);
+
+  // Create a string containing the JavaScript source code.
+  Handle<String> source = String::New("'Hello' + ', World!'");
+
+  // Compile the source code.
+  Handle<Script> script = Script::Compile(source);
+
+  // Run the script to get the result.
+  Handle<Value> result = script->Run();
+
+  // Dispose the persistent context.
+  context.Dispose();
+
+  // Convert the result to an ASCII string and print it.
+  String::AsciiValue ascii(result);
+  printf("%s\n", *ascii);
+  return 0;
+
+}
Index: run.sh
===================================================================
--- run.sh	(revision 0)
+++ run.sh	(revision 0)
@@ -0,0 +1,138 @@
+#!/bin/bash
+
+export NACLDYNCODE=1
+export NACL_DANGEROUS_ENABLE_FILE_ACCESS=1
+export NACL_ALLOW_DYNCODE_REPLACEMENT=1
+
+TOP=$(pwd)
+if [[ "$(uname -s)" == "Linux" ]]
+then
+  HOSTOS="linux"
+elif [[ "$(uname -s)" == "Darwin" ]]
+then
+  HOSTOS="mac"
+else
+  echo Unknown OS: $(uname -s)
+  exit 1
+fi
+
+export NACLSDK="$TOP/../nacl/native_client/toolchain/${HOSTOS}_x86/bin"
+CXX="$NACLSDK/nacl-g++"
+GDB="$NACLSDK/nacl-gdb"
+CXXFLAGS="-m32 -g"
+LDFLAGS="-Wl,--section-start,.rodata=0x20000000"
+
+TESTMODE="shell"
+MODE="debug"
+VERBOSE="off"
+ARCH="ia32"
+OS="nacl"
+V8="v8_g"
+SCONSFLAGS="" # updated below
+SEL_LDR_DBG="$TOP/../nacl/native_client/scons-out/dbg-${HOSTOS}-x86-32/staging/sel_ldr"
+SEL_LDR_OPT="$TOP/../nacl/native_client/scons-out/opt-${HOSTOS}-x86-32/staging/sel_ldr"
+SEL_LDR=$SEL_LDR_DBG
+SEL_LDR_FLAGS="--"
+V8_SHELL="shell_g"
+
+while ! test -z "$1"
+do
+  case "$1" in
+
+    sunspider)
+      TESTMODE="sunspider"
+    ;;
+
+    benchmark)
+      TESTMODE="benchmark"
+    ;;
+
+    test)
+      TESTMODE="test"
+    ;;
+
+    release)
+      MODE="release"
+      V8="v8"
+      V8_SHELL="shell"
+      if test "$OS" == "nacl"
+      then
+        SEL_LDR=$SEL_LDR_OPT
+      fi
+    ;;
+
+    hello)
+      TESTMODE="hello"
+    ;;
+
+    native)
+      CXX=g++
+      OS=$HOSTOS
+      if [[ "$OS" == "mac" ]]
+      then
+        OS+="os"
+      fi
+      SEL_LDR=""
+      SEL_LDR_FLAGS=""
+    ;;
+
+    nacl)
+    ;;
+
+    *)
+      echo Unknown option: "$1" >&2
+      exit 1
+    ;;
+  esac
+  shift
+done
+
+SCONSFLAGS="mode=$MODE sample=shell verbose=$VERBOSE arch=$ARCH os=$OS debuggersupport=off -j2"
+TESTFLAGS="--report --time --mode=$MODE --arch=$ARCH -S verbose=$VERBOSE -S os=$OS -S debuggersupport=off -S -j2 es5conform message cctest mozilla mjsunit"
+
+
+function run() {
+  echo "$@" >&2
+  eval "( $@ )" || exit 1
+}
+
+case "$TESTMODE" in
+
+  shell)
+    run scons $SCONSFLAGS
+  ;;
+
+  hello)
+    run scons $SCONSFLAGS
+    run $CXX $CXXFLAGS $LDFLAGS -o hello samples/hello.cc -L. -I./include -l$V8 -lpthread
+    run $SEL_LDR $SEL_LDR_FLAGS ./hello
+  ;;
+
+  test)
+    if ! test -z "$SEL_LDR"
+    then
+      TESTFLAGS+=" --special-command=$SEL_LDR%20-a%20-c%20--@"
+    fi
+    run ./tools/test.py $TESTFLAGS
+  ;;
+
+  benchmark)
+    run scons $SCONSFLAGS
+    run "cd benchmarks && run $SEL_LDR $SEL_LDR_FLAGS ../$V8_SHELL run.js"
+  ;;
+
+  sunspider)
+    run scons $SCONSFLAGS
+    cat > SunSpider/v8 << EOF
+#!/bin/sh
+export NACLDYNCODE="1"
+export NACL_DANGEROUS_ENABLE_FILE_ACCESS="1"
+export NACL_ALLOW_DYNCODE_REPLACEMENT="1"
+echo $SEL_LDR $SEL_LDR_FLAGS ../$V8_SHELL --expose-gc \$@ >&2
+exec $SEL_LDR $SEL_LDR_FLAGS ../$V8_SHELL --expose-gc \$@
+EOF
+    chmod +x SunSpider/v8
+    run "cd SunSpider && run perl sunspider --runs 1 --shell ./v8"
+  ;;
+
+esac
Index: src/api.cc
===================================================================
--- src/api.cc	(revision 4925)
+++ src/api.cc	(working copy)
@@ -4261,6 +4261,9 @@
 
 
 Local<Value> Debug::GetMirror(v8::Handle<v8::Value> obj) {
+#ifdef NACL
+  return Local<Value>();
+#endif
   if (!i::V8::IsRunning()) return Local<Value>();
   ON_BAILOUT("v8::Debug::GetMirror()", return Local<Value>());
   ENTER_V8;
Index: src/naclcode.h
===================================================================
--- src/naclcode.h	(revision 0)
+++ src/naclcode.h	(revision 0)
@@ -0,0 +1,79 @@
+// Copyright 2006-2010 the V8 project authors. All rights reserved.
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+//       copyright notice, this list of conditions and the following
+//       disclaimer in the documentation and/or other materials provided
+//       with the distribution.
+//     * Neither the name of Google Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef V8_NACLCODE_H_
+#define V8_NACLCODE_H_
+
+#include <stddef.h>
+
+namespace v8 {
+namespace internal {
+
+class Code;
+
+class NaClCode {
+public:
+  typedef Code* Tag;
+
+  // Allocate space to place the code
+  static uint8_t* Allocate(size_t bytes, Tag backpointer = 0);
+  
+  // Deallocate previously allocated code
+  static void Deallocate(uint8_t* ptr, size_t bytes);
+
+  // Install Code in a previously allocated space
+  static void Install(uint8_t* dst, uint8_t* src, size_t bytes);
+  
+  // Retrieve the Code* given at allocation time
+  static Tag GetBackpointer(uint8_t* inst);
+  
+  // Retrieve the Code* given at allocation time
+  // With an arbitrary pointer inside the region
+  static Tag Search(uint8_t* inst);
+  
+  // True if the target code is nacl text
+  static bool IsProtectedCode(uint8_t* dst);
+
+  // Patch a subset of a single bundle, target region cant cross bundle
+  static void Modify(uint8_t* dst, uint8_t* src, size_t bytes);
+
+  // Change the value of a single target word
+  template<typename T>
+  static inline void PatchWord(T* dst, T val){
+    Modify(reinterpret_cast<uint8_t*>(dst),
+           reinterpret_cast<uint8_t*>(&val),
+           sizeof(T));
+  }
+
+private:
+  NaClCode();
+};
+
+}} //v8::internal
+
+#endif// V8_NACLCODE_H_
+
Index: src/heap.cc
===================================================================
--- src/heap.cc	(revision 4925)
+++ src/heap.cc	(working copy)
@@ -45,6 +45,7 @@
 #include "regexp-macro-assembler.h"
 #include "arm/regexp-macro-assembler-arm.h"
 #endif
+#include "naclcode.h"
 
 
 namespace v8 {
@@ -718,6 +719,11 @@
 
 
 Object* Heap::FindCodeObject(Address a) {
+  //NACL_CHANGE: try the NaClCode heap
+  Code* c = NaClCode::Search(a);
+  if(c != NULL){
+    return c;
+  }
   Object* obj = code_space_->FindObject(a);
   if (obj->IsFailure()) {
     obj = lo_space_->FindObject(a);
@@ -2301,7 +2307,8 @@
                          Code::Flags flags,
                          Handle<Object> self_reference) {
   // Compute size
-  int body_size = RoundUp(desc.instr_size + desc.reloc_size, kObjectAlignment);
+  int inst_size = RoundUp(desc.instr_size, Code::kCodeAlignment);
+  int body_size = RoundUp(desc.reloc_size, kObjectAlignment);
   int sinfo_size = 0;
   if (sinfo != NULL) sinfo_size = sinfo->Serialize(NULL);
   int obj_size = Code::SizeFor(body_size, sinfo_size);
@@ -2319,7 +2326,7 @@
   HeapObject::cast(result)->set_map(code_map());
   Code* code = Code::cast(result);
   ASSERT(!CodeRange::exists() || CodeRange::contains(code->address()));
-  code->set_instruction_size(desc.instr_size);
+  code->set_instruction_size(inst_size);
   code->set_relocation_size(desc.reloc_size);
   code->set_sinfo_size(sinfo_size);
   code->set_flags(flags);
@@ -2328,6 +2335,10 @@
   if (!self_reference.is_null()) {
     *(self_reference.location()) = code;
   }
+
+  //NACL_CHANGE: split instructions from main code object
+  code->set_external_instructions(NaClCode::Allocate(inst_size, code));
+
   // Migrate generated code.
   // The generated code can contain Object** values (typically from handles)
   // that are dereferenced during the copy to point directly to the actual heap
@@ -2368,8 +2379,8 @@
 
 
 Object* Heap::CopyCode(Code* code, Vector<byte> reloc_info) {
-  int new_body_size = RoundUp(code->instruction_size() + reloc_info.length(),
-                              kObjectAlignment);
+  //NACL_CHANGE: dont include instruction_size
+  int new_body_size = RoundUp(reloc_info.length(), kObjectAlignment);
 
   int sinfo_size = code->sinfo_size();
 
Index: src/objects.cc
===================================================================
--- src/objects.cc	(revision 4925)
+++ src/objects.cc	(working copy)
@@ -5293,32 +5293,33 @@
 
 
 void Code::Relocate(intptr_t delta) {
-  for (RelocIterator it(this, RelocInfo::kApplyMask); !it.done(); it.next()) {
-    it.rinfo()->apply(delta);
-  }
-  CPU::FlushICache(instruction_start(), instruction_size());
+  //NACL_CHANGE: with split code/data, no longer need to do anything on relocate
+ //for (RelocIterator it(this, RelocInfo::kApplyMask); !it.done(); it.next()) {
+ //  it.rinfo()->apply(delta);
+ //}
+ //CPU::FlushICache(instruction_start(), instruction_size());
 }
 
 
 void Code::CopyFrom(const CodeDesc& desc) {
-  // copy code
-  memmove(instruction_start(), desc.buffer, desc.instr_size);
+  //NACL_CHANGE:
+  // rewrote this function to be "3rd person"
+  Address final_inst = instruction_start();
+  Address tmp_inst = desc.buffer;
+  
+  // copy reloc info
+  memcpy(relocation_start(),
+         desc.buffer + desc.buffer_size - desc.reloc_size,
+         desc.reloc_size);
 
-  // fill gap with zero bytes
-  { byte* p = instruction_start() + desc.instr_size;
-    byte* q = relocation_start();
-    while (p < q) {
-      *p++ = 0;
-    }
-  }
+  //temporarily swing code pointer to writable buffer
+  set_external_instructions(tmp_inst);
+  
+  //pad up to 32 byte boundary with nops 
+  memset(tmp_inst+desc.instr_size, 0x90, instruction_size()-desc.instr_size);
 
-  // copy reloc info
-  memmove(relocation_start(),
-          desc.buffer + desc.buffer_size - desc.reloc_size,
-          desc.reloc_size);
-
   // unbox handles and relocate
-  intptr_t delta = instruction_start() - desc.buffer;
+  intptr_t delta = final_inst - desc.buffer;//based on final inst
   int mode_mask = RelocInfo::kCodeTargetMask |
                   RelocInfo::ModeMask(RelocInfo::EMBEDDED_OBJECT) |
                   RelocInfo::kApplyMask;
@@ -5333,14 +5334,45 @@
       // pointers to the first instruction in the code object
       Handle<Object> p = it.rinfo()->target_object_handle(origin);
       Code* code = Code::cast(*p);
-      it.rinfo()->set_target_address(code->instruction_start());
+      //extra offset since jump targets are relative
+      it.rinfo()->set_target_address(code->instruction_start(), 
+                                     final_inst-tmp_inst);
     } else {
       it.rinfo()->apply(delta);
     }
   }
+
+  //install instructions 
+  NaClCode::Install(final_inst, tmp_inst, instruction_size());
+
+  //swing code pointer to executable buffer
+  set_external_instructions(final_inst);
+  
   CPU::FlushICache(instruction_start(), instruction_size());
 }
+  
+#ifdef DEBUG
+void Code::CodeDumpAsm(const char* filename){
+  byte* p = instruction_start();
+  byte* q = p+instruction_size();
+  FILE* fp = fopen(filename, "w");
+  CHECK(fp!=0);
+  fprintf(fp, ".global _start\n_start:\n");
+  if(p < q) {
+    fprintf(fp, ".byte %d", *p++);
+    while (p < q) {
+      fprintf(fp, ", %d", *p++);
+    }
+  }
+  fclose(fp);
+}
+#endif
 
+#ifdef NACL
+void Code::NaClOnDelete() {
+  NaClCode::Deallocate(instruction_start(), instruction_size());
+}
+#endif
 
 // Locate the source position which is closest to the address in the code. This
 // is using the source position information embedded in the relocation info.
Index: src/regexp-macro-assembler.h
===================================================================
--- src/regexp-macro-assembler.h	(revision 4925)
+++ src/regexp-macro-assembler.h	(working copy)
@@ -68,6 +68,9 @@
   // stack by an earlier PushBacktrack(Label*).
   virtual void Backtrack() = 0;
   virtual void Bind(Label* label) = 0;
+#if defined(NACL)
+  virtual void Bind_Aligned(Label* label) { Bind(label); }
+#endif
   virtual void CheckAtStart(Label* on_at_start) = 0;
   // Dispatch after looking the current character up in a 2-bits-per-entry
   // map.  The destinations vector has up to 4 labels.
Index: src/conversions.cc
===================================================================
--- src/conversions.cc	(revision 4925)
+++ src/conversions.cc	(working copy)
@@ -25,6 +25,8 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+#include <stdlib.h>
+#include <stdio.h>
 #include <stdarg.h>
 #include <limits.h>
 
@@ -103,7 +105,15 @@
 }
 
 
+#ifdef NACL
+// this special case can be remove when the following bug is fixed:
+// http://code.google.com/p/nativeclient/issues/detail?id=702
+inline double gay_strtod(const char* s00, char** se){
+  return strtod(s00,se);
+}
+#else
 extern "C" double gay_strtod(const char* s00, const char** se);
+#endif
 
 // Maximum number of significant digits in decimal representation.
 // The longest possible double in decimal representation is
@@ -737,12 +747,59 @@
   return InternalStringToDouble(str, end, flags, empty_string_val);
 }
 
-
+#ifndef NACL
 extern "C" char* dtoa(double d, int mode, int ndigits,
                       int* decpt, int* sign, char** rve);
 
 extern "C" void freedtoa(char* s);
+#endif
 
+#ifdef NACL
+//emulate dtoa with snprintf
+void nacl_dtoa(char* decimal_rep, int decimal_rep_len, double value, int p, int* decimal_point, int* sign) {
+  memset(decimal_rep, 0, decimal_rep_len);
+  *decimal_point = 0;
+  *sign = 0;
+
+  //generate fmt dynamically:
+  //char fmt[8];  //max size "%21e\0" = 5
+  //sprintf(fmt, "%%.%de", p-1); //build format like: "%.3e"
+  //or:
+
+  //use a lookup table:
+  static const char* fmts[] = {
+    "%.0e",  "%.1e",  "%.2e",  "%.3e",  "%.4e",  "%.5e",  "%.6e",
+    "%.7e",  "%.8e",  "%.9e",  "%.10e", "%.11e", "%.12e", "%.13e",
+    "%.14e", "%.15e", "%.16e", "%.17e", "%.18e", "%.19e", "%.20e"
+  };
+  CHECK(p >= 1 && p <= 21);
+  const char* fmt = fmts[p-1];
+
+  char tmp[32]; //max size "-1." + 20 digits + "e+NNNN\0" =  30
+  sprintf(tmp, fmt, value);
+  //scan through tmp, copying mantissa digits to decimal_rep
+  for(char *i=tmp,*o=decimal_rep; i<tmp+sizeof tmp; ++i) {
+    if('0'<=*i && *i<='9') {
+      //copy digit
+      *o++ = *i;
+    } else if(*i=='.') {
+      //ignore
+    } else if(*i=='-') {
+      *sign = 1;
+    } else if(*i=='e') {
+      //store exponent+1 to decimal_point and exit loop
+      CHECK(sscanf(i+1, "%d", decimal_point)==1);
+      *decimal_point+=1;
+      break;
+    } else {
+      UNIMPLEMENTED();
+    }
+  }
+}
+#endif
+
+
+
 const char* DoubleToCString(double v, Vector<char> buffer) {
   StringBuilder builder(buffer.start(), buffer.length());
 
@@ -767,6 +824,9 @@
       int decimal_point;
       int sign;
       char* decimal_rep;
+#ifdef NACL
+      char decimal_rep_buf[32];
+#endif
       bool used_gay_dtoa = false;
       const int kV8DtoaBufferCapacity = kBase10MaximalLength + 1;
       char v8_dtoa_buffer[kV8DtoaBufferCapacity];
@@ -777,7 +837,12 @@
                         &sign, &length, &decimal_point)) {
         decimal_rep = v8_dtoa_buffer;
       } else {
+#ifdef NACL
+        decimal_rep = decimal_rep_buf;
+        nacl_dtoa(decimal_rep_buf, sizeof decimal_rep_buf, v, 21, &decimal_point, &sign);
+#else
         decimal_rep = dtoa(v, 0, 0, &decimal_point, &sign, NULL);
+#endif
         used_gay_dtoa = true;
         length = StrLength(decimal_rep);
       }
@@ -815,7 +880,9 @@
         builder.AddFormatted("%d", exponent);
       }
 
+#ifndef NACL
       if (used_gay_dtoa) freedtoa(decimal_rep);
+#endif
     }
   }
   return builder.Finalize();
@@ -946,8 +1013,6 @@
   return builder.Finalize();
 }
 
-
-
 char* DoubleToExponentialCString(double value, int f) {
   // f might be -1 to signal that f was undefined in JavaScript.
   ASSERT(f >= -1 && f <= 20);
@@ -961,6 +1026,15 @@
   // Find a sufficiently precise decimal representation of n.
   int decimal_point;
   int sign;
+#ifdef NACL
+  char decimal_rep[32];
+  if (f == -1) {
+    nacl_dtoa(decimal_rep, sizeof decimal_rep, value, 21, &decimal_point, &sign);
+    f = StrLength(decimal_rep) - 1;
+  } else {
+    nacl_dtoa(decimal_rep, sizeof decimal_rep, value, f+1, &decimal_point, &sign);
+  }
+#else
   char* decimal_rep = NULL;
   if (f == -1) {
     decimal_rep = dtoa(value, 0, 0, &decimal_point, &sign, NULL);
@@ -968,6 +1042,7 @@
   } else {
     decimal_rep = dtoa(value, 2, f + 1, &decimal_point, &sign, NULL);
   }
+#endif
   int decimal_rep_length = StrLength(decimal_rep);
   ASSERT(decimal_rep_length > 0);
   ASSERT(decimal_rep_length <= f + 1);
@@ -977,12 +1052,13 @@
   char* result =
       CreateExponentialRepresentation(decimal_rep, exponent, negative, f+1);
 
+#ifndef NACL
   freedtoa(decimal_rep);
+#endif
 
   return result;
 }
 
-
 char* DoubleToPrecisionCString(double value, int p) {
   ASSERT(p >= 1 && p <= 21);
 
@@ -993,9 +1069,14 @@
   }
 
   // Find a sufficiently precise decimal representation of n.
-  int decimal_point;
-  int sign;
+  int decimal_point = 0;
+  int sign = 0;
+#ifdef NACL
+  char decimal_rep[32]; //max size is p+1
+  nacl_dtoa(decimal_rep, sizeof decimal_rep, value, p, &decimal_point, &sign);
+#else
   char* decimal_rep = dtoa(value, 2, p, &decimal_point, &sign, NULL);
+#endif
   int decimal_rep_length = StrLength(decimal_rep);
   ASSERT(decimal_rep_length <= p);
 
@@ -1040,7 +1121,9 @@
     result = builder.Finalize();
   }
 
+#ifndef NACL
   freedtoa(decimal_rep);
+#endif
   return result;
 }
 
Index: src/runtime.cc
===================================================================
--- src/runtime.cc	(revision 4925)
+++ src/runtime.cc	(working copy)
@@ -9045,7 +9045,7 @@
   ASSERT(args.length() == 3);
   CONVERT_ARG_CHECKED(JSFunction, fun, 0);
   Handle<SharedFunctionInfo> shared(fun->shared());
-  CONVERT_NUMBER_CHECKED(int32_t, source_position, Int32, args[1]);
+  CONVERT_NUMBER_CHECKED(int, source_position, Int32, args[1]);
   RUNTIME_ASSERT(source_position >= 0);
   Handle<Object> break_point_object_arg = args.at<Object>(2);
 
@@ -10119,8 +10119,8 @@
 
   HandleScope scope;
 
-  limit = Max(limit, 0);  // Ensure that limit is not negative.
-  int initial_size = Min(limit, 10);
+  limit = Max<int32_t>(limit, 0);  // Ensure that limit is not negative.
+  int initial_size = Min<int32_t>(limit, 10);
   Handle<JSArray> result = Factory::NewJSArray(initial_size * 3);
 
   StackFrameIterator iter;
Index: src/objects.h
===================================================================
--- src/objects.h	(revision 4925)
+++ src/objects.h	(working copy)
@@ -2726,6 +2726,11 @@
   // [instruction_size]: Size of the native instructions
   inline int instruction_size();
   inline void set_instruction_size(int value);
+  
+  //NACL_CHANGE: add external_instructions field:
+  // [external_instructions]: Pointer to the native instructions
+  inline byte* external_instructions();
+  inline void set_external_instructions(byte* value);
 
   // [relocation_size]: Size of relocation information.
   inline int relocation_size();
@@ -2784,7 +2789,7 @@
 
   // Returns the address of the first instruction.
   inline byte* instruction_start();
-
+  
   // Returns the size of the instructions, padding, and relocation information.
   inline int body_size();
 
@@ -2812,7 +2817,9 @@
   static int SizeFor(int body_size, int sinfo_size) {
     ASSERT_SIZE_TAG_ALIGNED(body_size);
     ASSERT_SIZE_TAG_ALIGNED(sinfo_size);
+    //NACL_CHANGE: don't make room for instructions
     return RoundUp(kHeaderSize + body_size + sinfo_size, kCodeAlignment);
+    //return RoundUp(kHeaderSize + sinfo_size, kCodeAlignment);
   }
 
   // Calculate the size of the code object to report for log events. This takes
@@ -2837,7 +2844,13 @@
 #ifdef DEBUG
   void CodePrint();
   void CodeVerify();
+  void CodeDumpAsm(const char* filename);
 #endif
+
+#ifdef NACL
+  void NaClOnDelete();
+#endif
+
   // Code entry points are aligned to 32 bytes.
   static const int kCodeAlignmentBits = 5;
   static const int kCodeAlignment = 1 << kCodeAlignmentBits;
@@ -2845,7 +2858,9 @@
 
   // Layout description.
   static const int kInstructionSizeOffset = HeapObject::kHeaderSize;
-  static const int kRelocationSizeOffset = kInstructionSizeOffset + kIntSize;
+  //NACL_CHANGE: add external_instructions field:
+  static const int kExternalInstructionsOffset = kInstructionSizeOffset + kPointerSize;
+  static const int kRelocationSizeOffset = kExternalInstructionsOffset + kIntSize;
   static const int kSInfoSizeOffset = kRelocationSizeOffset + kIntSize;
   static const int kFlagsOffset = kSInfoSizeOffset + kIntSize;
   static const int kKindSpecificFlagsOffset  = kFlagsOffset + kIntSize;
Index: src/SConscript
===================================================================
--- src/SConscript	(revision 4925)
+++ src/SConscript	(working copy)
@@ -61,6 +61,8 @@
     dtoa.cc
     execution.cc
     factory.cc
+    fast-dtoa.cc
+    fixed-dtoa.cc
     flags.cc
     flow-graph.cc
     frame-element.cc
@@ -68,8 +70,6 @@
     full-codegen.cc
     func-name-inferrer.cc
     global-handles.cc
-    fast-dtoa.cc
-    fixed-dtoa.cc
     handles.cc
     hashmap.cc
     heap-profiler.cc
@@ -83,6 +83,7 @@
     log.cc
     mark-compact.cc
     messages.cc
+    naclcode.cc
     objects.cc
     oprofile-agent.cc
     parser.cc
@@ -206,6 +207,7 @@
   'os:android': ['platform-linux.cc', 'platform-posix.cc'],
   'os:macos':   ['platform-macos.cc', 'platform-posix.cc'],
   'os:solaris': ['platform-solaris.cc', 'platform-posix.cc'],
+  'os:nacl':    ['platform-nacl.cc', 'platform-posix.cc'],
   'os:nullos':  ['platform-nullos.cc'],
   'os:win32':   ['platform-win32.cc'],
   'mode:release': [],
@@ -237,6 +239,9 @@
   'os:solaris': [
     'd8-posix.cc'
   ],
+  'os:nacl': [
+    'd8-posix.cc'
+  ],
   'os:win32': [
     'd8-windows.cc'
   ],
Index: src/objects-debug.cc
===================================================================
--- src/objects-debug.cc	(revision 4925)
+++ src/objects-debug.cc	(working copy)
@@ -589,6 +589,10 @@
     case JS_BUILTINS_OBJECT_TYPE: return "JS_BUILTINS_OBJECT";
     case JS_GLOBAL_PROXY_TYPE: return "JS_GLOBAL_PROXY";
     case PROXY_TYPE: return "PROXY";
+#ifndef ENABLE_DEBUGGER_SUPPORT
+    case DEBUG_INFO_TYPE:       return "DEBUG_INFO_TYPE";
+    case BREAK_POINT_INFO_TYPE: return "BREAK_POINT_INFO_TYPE";
+#endif
 #define MAKE_STRUCT_CASE(NAME, Name, name) case NAME##_TYPE: return #NAME;
   STRUCT_LIST(MAKE_STRUCT_CASE)
 #undef MAKE_STRUCT_CASE
Index: src/utils.h
===================================================================
--- src/utils.h	(revision 4925)
+++ src/utils.h	(working copy)
@@ -391,6 +391,7 @@
   // Factory method for creating empty vectors.
   static Vector<T> empty() { return Vector<T>(NULL, 0); }
 
+
  protected:
   void set_start(T* start) { start_ = start; }
 
@@ -399,7 +400,14 @@
   int length_;
 };
 
+#ifdef NACL
+template<typename A, typename B>
+inline bool operator==(const Vector<A>& a, const Vector<B>& b) {
+  return a.length()==b.length() && (void*)a.start()==(void*)b.start();
+}
+#endif
 
+
 // A temporary assignment sets a (non-local) variable to a value on
 // construction and resets it the value on destruction.
 template <typename T>
@@ -578,6 +586,7 @@
 static inline void MemCopy(void* dest, const void* src, size_t size) {
   static MemCopyFunction memcopy = CreateMemCopyFunction();
   (*memcopy)(dest, src, size);
+
 #ifdef DEBUG
   CHECK_EQ(0, memcmp(dest, src, size));
 #endif
Index: src/serialize.cc
===================================================================
--- src/serialize.cc	(revision 4925)
+++ src/serialize.cc	(working copy)
@@ -364,6 +364,7 @@
       UNCLASSIFIED,
       6,
       "RegExpStack::limit_address()");
+#ifndef V8_INTERPRETED_REGEXP
   Add(ExternalReference::address_of_regexp_stack_memory_address().address(),
       UNCLASSIFIED,
       7,
@@ -376,6 +377,7 @@
       UNCLASSIFIED,
       9,
       "OffsetsVector::static_offsets_vector");
+#endif
   Add(ExternalReference::new_space_start().address(),
       UNCLASSIFIED,
       10,
@@ -1002,7 +1004,7 @@
 
 void StartupSerializer::SerializeStrongReferences() {
   // No active threads.
-  CHECK_EQ(NULL, ThreadState::FirstInUse());
+  CHECK_EQ((void*)0, ThreadState::FirstInUse());
   // No active or weak handles.
   CHECK(HandleScopeImplementer::instance()->blocks()->is_empty());
   CHECK_EQ(0, GlobalHandles::NumberOfWeakHandles());
Index: src/builtins.cc
===================================================================
--- src/builtins.cc	(revision 4925)
+++ src/builtins.cc	(working copy)
@@ -1269,7 +1269,7 @@
 
 static void Generate_StoreIC_ArrayLength(MacroAssembler* masm) {
   StoreIC::GenerateArrayLength(masm);
-}
+}	
 
 
 static void Generate_KeyedStoreIC_Generic(MacroAssembler* masm) {
@@ -1452,6 +1452,9 @@
   // separate code object for each one.
   for (int i = 0; i < builtin_count; i++) {
     if (create_heap_objects) {
+#if defined(DEBUG) || defined(NACL)
+      memset(buffer,0x90, sizeof buffer); // fill buffer with halts
+#endif
       MacroAssembler masm(buffer, sizeof buffer);
       // Generate the code/adaptor.
       typedef void (*Generator)(MacroAssembler*, int, BuiltinExtraArguments);
Index: src/jsregexp.cc
===================================================================
--- src/jsregexp.cc	(revision 4925)
+++ src/jsregexp.cc	(working copy)
@@ -796,7 +796,11 @@
   macro_assembler_->PushBacktrack(&fail);
   Trace new_trace;
   start->Emit(this, &new_trace);
+#if defined(NACL)
+  macro_assembler_->Bind_Aligned(&fail);
+#else
   macro_assembler_->Bind(&fail);
+#endif
   macro_assembler_->Fail();
   while (!work_list.is_empty()) {
     work_list.RemoveLast()->Emit(this, &new_trace);
@@ -1067,7 +1071,11 @@
   successor->Emit(compiler, &new_state);
 
   // On backtrack we need to restore state.
+#if defined(NACL)
+  assembler->Bind_Aligned(&undo);
+#else
   assembler->Bind(&undo);
+#endif
   RestoreAffectedRegisters(assembler,
                            max_register,
                            registers_to_pop,
Index: src/checks.h
===================================================================
--- src/checks.h	(revision 4925)
+++ src/checks.h	(working copy)
@@ -29,6 +29,7 @@
 #define V8_CHECKS_H_
 
 #include <string.h>
+#include <sstream>
 
 #include "flags.h"
 
@@ -67,7 +68,6 @@
 // prints a message to stderr and aborts.
 #define CHECK(condition) CheckHelper(__FILE__, __LINE__, #condition, condition)
 
-
 // Helper function used by the CHECK_EQ function when given int
 // arguments.  Should not be called directly.
 static inline void CheckEqualsHelper(const char* file, int line,
@@ -81,6 +81,7 @@
 }
 
 
+
 // Helper function used by the CHECK_EQ function when given int64_t
 // arguments.  Should not be called directly.
 static inline void CheckEqualsHelper(const char* file, int line,
@@ -102,7 +103,6 @@
   }
 }
 
-
 // Helper function used by the CHECK_NE function when given int
 // arguments.  Should not be called directly.
 static inline void CheckNonEqualsHelper(const char* file,
@@ -245,15 +245,52 @@
                        const char* value_source,
                        v8::Handle<v8::Value> value);
 
+#ifdef NACL
 
+template <typename A, typename B>
+inline bool check_cmp(A a, B b) {
+  return a==b;
+}
+template <>
+inline bool check_cmp(int a, unsigned int b) {
+  return (unsigned int)a==b;
+}
+template <>
+inline bool check_cmp(int a, unsigned long b) {
+  return (unsigned long)a==b;
+}
+template <>
+inline bool check_cmp(unsigned int b, int a) {
+  return (unsigned int)a==b;
+}
+template <>
+inline bool check_cmp(unsigned long b, int a) {
+  return (unsigned long)a==b;
+}
+template <>
+inline bool check_cmp(const char* a , const char* b) { return strcmp(a,b)==0; }
+template <typename T>
+inline bool check_cmp(int a , T* b) {
+  CHECK(a==0);
+  return b==0;
+}
+template <typename T>
+inline bool check_cmp(T* b, int a) {
+  CHECK(a==0);
+  return b==0;
+}
+
+#define CHECK_EQ(a, b) CHECK( check_cmp((a), (b)))
+#define CHECK_NE(a, b) CHECK(!check_cmp((a), (b)))
+#else
 #define CHECK_EQ(expected, value) CheckEqualsHelper(__FILE__, __LINE__, \
   #expected, expected, #value, value)
 
 
 #define CHECK_NE(unexpected, value) CheckNonEqualsHelper(__FILE__, __LINE__, \
   #unexpected, unexpected, #value, value)
+#endif
 
-
 #define CHECK_GT(a, b) CHECK((a) > (b))
 #define CHECK_GE(a, b) CHECK((a) >= (b))
 
Index: src/disassembler.cc
===================================================================
--- src/disassembler.cc	(revision 4925)
+++ src/disassembler.cc	(working copy)
@@ -231,8 +231,11 @@
           out.AddFormatted(" constructor,");
         }
         Code* code = Code::GetCodeFromTargetAddress(relocinfo.target_address());
-        Code::Kind kind = code->kind();
-        if (code->is_inline_cache_stub()) {
+        Code::Kind kind = (code!=NULL ? code->kind() : Code::FIRST_IC_KIND);
+        
+        if (code == NULL ) {
+          out.AddFormatted("    ;; (error-decoding)");
+        } else if (code->is_inline_cache_stub()) {
           if (rmode == RelocInfo::CODE_TARGET_CONTEXT) {
             out.AddFormatted(" contextual,");
           }
Index: src/ia32/assembler-ia32-inl.h
===================================================================
--- src/ia32/assembler-ia32-inl.h	(revision 4925)
+++ src/ia32/assembler-ia32-inl.h	(working copy)
@@ -39,6 +39,9 @@
 
 #include "cpu.h"
 #include "debug.h"
+#ifdef NACL
+#include "../naclcode.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -84,9 +87,9 @@
 }
 
 
-void RelocInfo::set_target_address(Address target) {
+void RelocInfo::set_target_address(Address target, intptr_t extraoffset) {
   ASSERT(IsCodeTarget(rmode_) || rmode_ == RUNTIME_ENTRY);
-  Assembler::set_target_address_at(pc_, target);
+  Assembler::set_target_address_at(pc_, target, extraoffset);
 }
 
 
@@ -261,7 +264,9 @@
 void Assembler::emit_code_relative_offset(Label* label) {
   if (label->is_bound()) {
     int32_t pos;
-    pos = label->pos() + Code::kHeaderSize - kHeapObjectTag;
+    //NACL: do instructions deref elsewhere
+    //pos = label->pos() + Code::kHeaderSize - kHeapObjectTag;
+    pos = label->pos();
     emit(pos);
   } else {
     emit_disp(label, Displacement::CODE_RELATIVE);
@@ -282,9 +287,19 @@
 }
 
 
-void Assembler::set_target_address_at(Address pc, Address target) {
+void Assembler::set_target_address_at(Address pc, Address target, intptr_t extraoffset) {
+  int32_t val = target - (pc + sizeof(int32_t) + extraoffset);
   int32_t* p = reinterpret_cast<int32_t*>(pc);
-  *p = target - (pc + sizeof(int32_t));
+#ifdef NACL
+  ASSERT((reinterpret_cast<uintptr_t>(target) & (NACL_CHUNK-1)) == 0);
+  if(NaClCode::IsProtectedCode(pc)) {
+    NaClCode::PatchWord(p, val);
+  }else{
+    *p = val;
+  }
+#else
+  *p = val;
+#endif
   CPU::FlushICache(p, sizeof(int32_t));
 }
 
Index: src/ia32/codegen-ia32.cc
===================================================================
--- src/ia32/codegen-ia32.cc	(revision 4925)
+++ src/ia32/codegen-ia32.cc	(working copy)
@@ -42,6 +42,9 @@
 #include "runtime.h"
 #include "scopes.h"
 #include "virtual-frame-inl.h"
+#ifdef NACL
+#include "naclcode.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -8774,7 +8777,11 @@
     __ test(receiver.reg(), Immediate(kSmiTagMask));
     deferred->Branch(zero);
 
+#if defined(NACL)
+    __ bind_aligned(deferred->patch_site());
+#else
     __ bind(deferred->patch_site());
+#endif
     // This is the map check instruction that will be patched (so we can't
     // use the double underscore macro that may insert instructions).
     // Initially use an invalid map to force a failure.
@@ -8784,6 +8791,9 @@
     // which allows the assert below to succeed and patching to work.
     deferred->Branch(not_equal);
 
+#if defined(NACL) && NACL_CHUNK==16
+    masm()->Align(NACL_CHUNK);
+#endif
     // The delta from the patch label to the load offset must be statically
     // known.
     ASSERT(masm()->SizeOfCodeGeneratedSince(deferred->patch_site()) ==
@@ -8849,7 +8859,11 @@
     // Check that the receiver has the expected map.
     // Initially, use an invalid map. The map is patched in the IC
     // initialization code.
-    __ bind(deferred->patch_site());
+#if defined(NACL)
+  __ bind_aligned(deferred->patch_site());
+#else
+  __ bind(deferred->patch_site());
+#endif
     // Use masm-> here instead of the double underscore macro since extra
     // coverage code can interfere with the patching.
     masm_->cmp(FieldOperand(receiver.reg(), HeapObject::kMapOffset),
@@ -11440,6 +11454,7 @@
 
   // Locate the code entry and call it.
   __ add(Operand(edx), Immediate(Code::kHeaderSize - kHeapObjectTag));
+  NACL_PATCH_INSTRUCTION_START(edx);
   __ CallCFunction(edx, kRegExpExecuteArguments);
 
   // Check the result.
@@ -12400,6 +12415,7 @@
   }
   __ mov(edx, Operand(edx, 0));  // deref address
   __ lea(edx, FieldOperand(edx, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(edx);
   __ call(Operand(edx));
 
   // Unlink this frame from the handler chain.
@@ -13529,11 +13545,16 @@
 #define __ masm.
 
 MemCopyFunction CreateMemCopyFunction() {
-  size_t actual_size;
+  size_t actual_size = 0;
+#ifdef NACL
+  byte* buffer = 0;//let masm handle buffers
+#else
   byte* buffer = static_cast<byte*>(OS::Allocate(Assembler::kMinimalBufferSize,
                                                  &actual_size,
                                                  true));
   CHECK(buffer);
+#endif
+
   HandleScope handles;
   MacroAssembler masm(buffer, static_cast<int>(actual_size));
 
@@ -13725,6 +13746,14 @@
 
   CodeDesc desc;
   masm.GetCode(&desc);
+
+#ifdef NACL
+  //must validate and copy to executable space
+  buffer = NaClCode::Allocate(RoundUp(desc.instr_size, 32));
+  memset(desc.buffer+desc.instr_size, 0xf4, RoundUp(desc.instr_size, 32)-desc.instr_size);
+  NaClCode::Install(buffer, desc.buffer, RoundUp(desc.instr_size, 32));
+#endif
+
   // Call the function from C++.
   return FUNCTION_CAST<MemCopyFunction>(buffer);
 }
Index: src/ia32/regexp-macro-assembler-ia32.cc
===================================================================
--- src/ia32/regexp-macro-assembler-ia32.cc	(revision 4925)
+++ src/ia32/regexp-macro-assembler-ia32.cc	(working copy)
@@ -154,7 +154,9 @@
   CheckPreemption();
   // Pop Code* offset from backtrack stack, add Code* and jump to location.
   Pop(ebx);
-  __ add(Operand(ebx), Immediate(masm_->CodeObject()));
+  //NACL_CHANGE: dont use code object directly
+  //__ add(Operand(ebx), Immediate(masm_->CodeObject()));
+  AddInstructionStartToRegister(ebx);
   __ jmp(Operand(ebx));
 }
 
@@ -163,6 +165,11 @@
   __ bind(label);
 }
 
+#if defined(NACL)
+void RegExpMacroAssemblerIA32::Bind_Aligned(Label* label) {
+  __ bind_aligned(label);
+}
+#endif
 
 void RegExpMacroAssemblerIA32::CheckCharacter(uint32_t c, Label* on_equal) {
   __ cmp(current_character(), c);
@@ -1154,7 +1161,9 @@
 
 void RegExpMacroAssemblerIA32::SafeReturn() {
   __ pop(ebx);
-  __ add(Operand(ebx), Immediate(masm_->CodeObject()));
+  //NACL_CHANGE: dont use code object directly
+  //__ add(Operand(ebx), Immediate(masm_->CodeObject()));
+  AddInstructionStartToRegister(ebx);
   __ jmp(Operand(ebx));
 }
 
@@ -1162,8 +1171,30 @@
 void RegExpMacroAssemblerIA32::SafeCallTarget(Label* name) {
   __ bind(name);
 }
+  
+inline void RegExpMacroAssemblerIA32::AddInstructionStartToRegister(Register reg) {
+  //NACL_CHANGE: added this function
 
+  //find a tmp that is different than reg
+  Register tmp = (reg.code()==eax.code() ? ebx : eax);
 
+  //spill current value of tmp
+  //TODO(janse): see if I really need spill or if I can trash tmp
+  //__ push(tmp);
+
+  // load code object and deref external code point
+  __ mov(tmp, Immediate(masm_->CodeObject()));
+  __ add(Operand(tmp), Immediate(Code::kHeaderSize - kHeapObjectTag));
+  NACL_PATCH_INSTRUCTION_START(tmp);
+
+  // add the computed value
+  __ add(reg, Operand(tmp));
+
+  //restore value of tmp
+  //__ pop(tmp);
+}
+
+
 void RegExpMacroAssemblerIA32::Push(Register source) {
   ASSERT(!source.is(backtrack_stackpointer()));
   // Notice: This updates flags, unlike normal Push.
Index: src/ia32/full-codegen-ia32.cc
===================================================================
--- src/ia32/full-codegen-ia32.cc	(revision 4925)
+++ src/ia32/full-codegen-ia32.cc	(working copy)
@@ -202,6 +202,11 @@
       __ push(eax);
       __ CallRuntime(Runtime::kTraceExit, 1);
     }
+#ifdef NACL
+    //make entire return sequence packed in one block
+    __ Align(32);
+#endif
+
 #ifdef DEBUG
     // Add a label for checking the size of the code used for returning.
     Label check_exit_codesize;
Index: src/ia32/codegen-ia32.h
===================================================================
--- src/ia32/codegen-ia32.h	(revision 4925)
+++ src/ia32/codegen-ia32.h	(working copy)
@@ -797,7 +797,7 @@
         args_in_registers_(false),
         args_reversed_(false),
         static_operands_type_(operands_type),
-        runtime_operands_type_(BinaryOpIC::DEFAULT),
+        runtime_operands_type_(FLAG_use_ic ? BinaryOpIC::DEFAULT : BinaryOpIC::GENERIC),
         name_(NULL) {
     if (static_operands_type_.IsSmi()) {
       mode_ = NO_OVERWRITE;
Index: src/ia32/regexp-macro-assembler-ia32.h
===================================================================
--- src/ia32/regexp-macro-assembler-ia32.h	(revision 4925)
+++ src/ia32/regexp-macro-assembler-ia32.h	(working copy)
@@ -48,6 +48,9 @@
   virtual void AdvanceRegister(int reg, int by);
   virtual void Backtrack();
   virtual void Bind(Label* label);
+#if defined(NACL)
+  virtual void Bind_Aligned(Label* label);
+#endif
   virtual void CheckAtStart(Label* on_at_start);
   virtual void CheckCharacter(uint32_t c, Label* on_equal);
   virtual void CheckCharacterAfterAnd(uint32_t c,
@@ -174,6 +177,11 @@
   inline void SafeReturn();
   inline void SafeCallTarget(Label* name);
 
+  // NACL_CHANGE:
+  // Add the pointer to the start of the instrcution block for this code to a 
+  // given register
+  inline void AddInstructionStartToRegister(Register reg);
+
   // Pushes the value of a register on the backtrack stack. Decrements the
   // stack pointer (ecx) by a word size and stores the register's value there.
   inline void Push(Register source);
Index: src/ia32/macro-assembler-ia32.cc
===================================================================
--- src/ia32/macro-assembler-ia32.cc	(revision 4925)
+++ src/ia32/macro-assembler-ia32.cc	(working copy)
@@ -35,6 +35,8 @@
 #include "runtime.h"
 #include "serialize.h"
 
+#define __ 
+
 namespace v8 {
 namespace internal {
 
@@ -70,7 +72,45 @@
   shr(addr, Page::kRegionSizeLog2);
 
   // Set dirty mark for region.
+#if defined(NACL)
+  //this special case can be removed once the following bug is fixed:
+  //http://code.google.com/p/nativeclient/issues/detail?id=688
+  //compute address of target word into object
+  mov(scratch, addr);
+  shr(scratch, 0x5);
+  shl(scratch, 0x2);
+  lea(object, Operand(object, Page::kDirtyFlagOffset));
+  add(object, Operand(scratch));
+  //compute mask into scratch
+  and_(addr,   0x1f);
+  mov(scratch, 0x1);
+  if(addr.is(ecx)){
+    //shift uses lower bits of addr/ecx
+    shl_cl(scratch);
+  }else if(!scratch.is(ecx)){
+    //temporarily put addr in ecx for shift, since shl_cl requires ecx
+    //ecx is unused, so just swap with it
+    xchg(ecx, addr);
+    shl_cl(scratch);
+    xchg(ecx, addr);
+  }else{
+    // scratch is ecx
+    // need 3 way swap to get valid register assignment
+    // addr    => scratch/ecx
+    // scratch => object
+    // object  => addr
+    xchg(object, scratch);
+    xchg(ecx, addr);
+    shl_cl(object);
+    //undo swap
+    xchg(ecx, addr);
+    xchg(object, scratch);
+  }
+  //mask target word
+  or_(Operand(object,0), scratch);
+#else
   bts(Operand(object, Page::kDirtyFlagOffset), addr);
+#endif
 }
 
 
@@ -1286,6 +1326,7 @@
     if (!code_constant.is_null()) {
       mov(edx, Immediate(code_constant));
       add(Operand(edx), Immediate(Code::kHeaderSize - kHeapObjectTag));
+      NACL_PATCH_INSTRUCTION_START(edx);
     } else if (!code_operand.is_reg(edx)) {
       mov(edx, code_operand);
     }
@@ -1345,6 +1386,7 @@
   SmiUntag(ebx);
   mov(edx, FieldOperand(edx, SharedFunctionInfo::kCodeOffset));
   lea(edx, FieldOperand(edx, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(edx);
 
   ParameterCount expected(ebx);
   InvokeCode(Operand(edx), expected, actual, flag);
@@ -1402,6 +1444,7 @@
     pop(target);
   }
   lea(target, FieldOperand(target, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(target);
 }
 
 
Index: src/ia32/assembler-ia32.cc
===================================================================
--- src/ia32/assembler-ia32.cc	(revision 4925)
+++ src/ia32/assembler-ia32.cc	(working copy)
@@ -42,9 +42,17 @@
 #include "macro-assembler.h"
 #include "serialize.h"
 
+//length of an Operator
+#define L(op) op.len_
+#define I(imm32) Immediate(imm32).is_int8() ? 1 : 4
+//min offset in the bundle we must be to use a call
+#define NACL_USE_CALL_THRESH 20
+
+
 namespace v8 {
 namespace internal {
 
+
 // -----------------------------------------------------------------------------
 // Implementation of CpuFeatures
 
@@ -67,8 +75,38 @@
   Assembler assm(NULL, 0);
   Label cpuid, done;
 #define __ assm.
+#ifdef NACL
   // Save old esp, since we are going to modify the stack.
   __ push(ebp);
+  __ push(ecx);
+  __ push(ebx);
+  __ mov(ebp, Operand(esp));
+
+  // Invoke CPUID with 1 in eax to get feature information in
+  // ecx:edx. Temporarily enable CPUID support because we know it's
+  // safe here.
+  __ mov(eax, 1);
+  supported_ = (1 << CPUID);
+  { Scope fscope(CPUID);
+    __ cpuid();
+  }
+  supported_ = 0;
+
+  // Move the result from ecx:edx to edx:eax and make sure to mark the
+  // CPUID feature as supported.
+  __ mov(eax, Operand(edx));
+  __ or_(eax, 1 << CPUID);
+  __ mov(edx, Operand(ecx));
+
+  // Done.
+  __ mov(esp, Operand(ebp));
+  __ pop(ebx);
+  __ pop(ecx);
+  __ pop(ebp);
+  __ ret(0);
+#else
+  // Save old esp, since we are going to modify the stack.
+  __ push(ebp);
   __ pushfd();
   __ push(ecx);
   __ push(ebx);
@@ -116,6 +154,7 @@
   __ popfd();
   __ pop(ebp);
   __ ret(0);
+#endif
 #undef __
 
   CodeDesc desc;
@@ -322,7 +361,8 @@
   // Clear the buffer in debug mode unless it was provided by the
   // caller in which case we can't be sure it's okay to overwrite
   // existing code in it; see CodePatcher::CodePatcher(...).
-#ifdef DEBUG
+#if defined(DEBUG) || defined(NACL)
+  //NACL_CHANGE: this is required for validation.... should figure out where it is using uninitialized memory
   if (own_buffer_) {
     memset(buffer_, 0xCC, buffer_size);  // int3
   }
@@ -372,8 +412,9 @@
 
 void Assembler::Align(int m) {
   ASSERT(IsPowerOf2(m));
-  while ((pc_offset() & (m - 1)) != 0) {
-    nop();
+  int left = m - (pc_offset() & (m-1));
+  if(left != m) {
+    nops(left);
   }
 }
 
@@ -385,7 +426,7 @@
 
 void Assembler::cpuid() {
   ASSERT(CpuFeatures::IsEnabled(CPUID));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xA2);
@@ -393,40 +434,42 @@
 
 
 void Assembler::pushad() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x60);
 }
 
 
 void Assembler::popad() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x61);
 }
 
 
 void Assembler::pushfd() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x9C);
 }
 
 
 void Assembler::popfd() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x9D);
 }
 
 
 void Assembler::push(const Immediate& x) {
-  EnsureSpace ensure_space(this);
-  last_pc_ = pc_;
   if (x.is_int8()) {
+    EnsureSpace ensure_space(this, 2);
+    last_pc_ = pc_;
     EMIT(0x6a);
     EMIT(x.x_);
   } else {
+    EnsureSpace ensure_space(this, 5);
+    last_pc_ = pc_;
     EMIT(0x68);
     emit(x);
   }
@@ -434,19 +477,25 @@
 
 
 void Assembler::push(Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x50 | src.code());
 }
 
 
 void Assembler::push(const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0xFF);
   emit_operand(esi, src);
 }
 
+void Assembler::push(byte* x, RelocInfo::Mode rmode) {
+  EnsureSpace ensure_space(this, 5);
+  last_pc_ = pc_;
+  EMIT(0x68);
+  emit(reinterpret_cast<uint32_t>(x), rmode);
+}
 
 void Assembler::pop(Register dst) {
   ASSERT(reloc_info_writer.last_pc() != NULL);
@@ -456,7 +505,12 @@
     // relocation information generated between the last instruction and this
     // pop instruction.
     byte instr = last_pc_[0];
-    if ((instr & ~0x7) == 0x50) {
+    if ((instr & ~0x7) == 0x50
+#ifdef NACL
+      //make sure we aren't at the end of a bundle
+      && (pc_offset()&31)<31 && (pc_offset()&31)>1
+#endif
+        ) {
       int push_reg_code = instr & 0x7;
       if (push_reg_code == dst.code()) {
         pc_ = last_pc_;
@@ -467,7 +521,7 @@
         // Convert 'push src; pop dst' to 'mov dst, src'.
         last_pc_[0] = 0x8b;
         Register src = { push_reg_code };
-        EnsureSpace ensure_space(this);
+        EnsureSpace ensure_space(this, 1);
         emit_operand(dst, Operand(src));
         if (FLAG_print_peephole_optimization) {
           PrintF("%d push/pop (reg->reg) eliminated\n", pc_offset());
@@ -505,7 +559,12 @@
         }
         return;
       }
-    } else if (instr == 0x6a && dst.is(eax)) {  // push of immediate 8 bit
+    } else if (instr == 0x6a && dst.is(eax)
+#ifdef NACL
+      //make sure we aren't at the end of a bundle
+      && (pc_offset()&31)<28
+#endif
+        ) {  // push of immediate 8 bit
       byte imm8 = last_pc_[1];
       if (imm8 == 0) {
         // 6a00         push 0x0
@@ -523,7 +582,7 @@
         // 6a00         push 0xXX
         // 58           pop eax
         last_pc_[0] = 0xb8;
-        EnsureSpace ensure_space(this);
+        EnsureSpace ensure_space(this, 3);
         if ((imm8 & 0x80) != 0) {
           EMIT(0xff);
           EMIT(0xff);
@@ -560,14 +619,14 @@
     // 0x712716   102  890424         mov [esp], eax
     // 0x712719   105  8b1424         mov edx, [esp]
   }
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x58 | dst.code());
 }
 
 
 void Assembler::pop(const Operand& dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x8F);
   emit_operand(eax, dst);
@@ -575,6 +634,9 @@
 
 
 void Assembler::enter(const Immediate& size) {
+#ifdef NACL
+  UNIMPLEMENTED();
+#endif
   EnsureSpace ensure_space(this);
   last_pc_ = pc_;
   EMIT(0xC8);
@@ -584,7 +646,7 @@
 
 
 void Assembler::leave() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0xC9);
 }
@@ -592,7 +654,7 @@
 
 void Assembler::mov_b(Register dst, const Operand& src) {
   ASSERT(dst.code() < 4);
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x8A);
   emit_operand(dst, src);
@@ -600,7 +662,7 @@
 
 
 void Assembler::mov_b(const Operand& dst, int8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(dst));
   last_pc_ = pc_;
   EMIT(0xC6);
   emit_operand(eax, dst);
@@ -610,7 +672,7 @@
 
 void Assembler::mov_b(const Operand& dst, Register src) {
   ASSERT(src.code() < 4);
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x88);
   emit_operand(src, dst);
@@ -618,7 +680,7 @@
 
 
 void Assembler::mov_w(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x8B);
@@ -627,7 +689,7 @@
 
 
 void Assembler::mov_w(const Operand& dst, Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(dst));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x89);
@@ -636,7 +698,7 @@
 
 
 void Assembler::mov(Register dst, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   EMIT(0xB8 | dst.code());
   emit(imm32);
@@ -644,7 +706,7 @@
 
 
 void Assembler::mov(Register dst, const Immediate& x) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   EMIT(0xB8 | dst.code());
   emit(x);
@@ -652,7 +714,7 @@
 
 
 void Assembler::mov(Register dst, Handle<Object> handle) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   EMIT(0xB8 | dst.code());
   emit(handle);
@@ -660,7 +722,7 @@
 
 
 void Assembler::mov(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x8B);
   emit_operand(dst, src);
@@ -668,7 +730,7 @@
 
 
 void Assembler::mov(Register dst, Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0x89);
   EMIT(0xC0 | src.code() << 3 | dst.code());
@@ -676,7 +738,7 @@
 
 
 void Assembler::mov(const Operand& dst, const Immediate& x) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(dst));
   last_pc_ = pc_;
   EMIT(0xC7);
   emit_operand(eax, dst);
@@ -685,7 +747,7 @@
 
 
 void Assembler::mov(const Operand& dst, Handle<Object> handle) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(dst));
   last_pc_ = pc_;
   EMIT(0xC7);
   emit_operand(eax, dst);
@@ -694,7 +756,7 @@
 
 
 void Assembler::mov(const Operand& dst, Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x89);
   emit_operand(src, dst);
@@ -702,7 +764,7 @@
 
 
 void Assembler::movsx_b(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xBE);
@@ -711,7 +773,7 @@
 
 
 void Assembler::movsx_w(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xBF);
@@ -720,7 +782,7 @@
 
 
 void Assembler::movzx_b(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xB6);
@@ -729,7 +791,7 @@
 
 
 void Assembler::movzx_w(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xB7);
@@ -761,7 +823,7 @@
 
 void Assembler::cmov(Condition cc, Register dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(CMOV));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   // Opcode: 0f 40 + cc /r.
   EMIT(0x0F);
@@ -771,14 +833,14 @@
 
 
 void Assembler::cld() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0xFC);
 }
 
 
 void Assembler::rep_movs() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF3);
   EMIT(0xA5);
@@ -786,7 +848,7 @@
 
 
 void Assembler::rep_stos() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF3);
   EMIT(0xAB);
@@ -794,18 +856,19 @@
 
 
 void Assembler::stos() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0xAB);
 }
 
 
 void Assembler::xchg(Register dst, Register src) {
-  EnsureSpace ensure_space(this);
   last_pc_ = pc_;
   if (src.is(eax) || dst.is(eax)) {  // Single-byte encoding.
+    EnsureSpace ensure_space(this, 1);
     EMIT(0x90 | (src.is(eax) ? dst.code() : src.code()));
   } else {
+    EnsureSpace ensure_space(this, 2);
     EMIT(0x87);
     EMIT(0xC0 | src.code() << 3 | dst.code());
   }
@@ -813,14 +876,14 @@
 
 
 void Assembler::adc(Register dst, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   emit_arith(2, Operand(dst), Immediate(imm32));
 }
 
 
 void Assembler::adc(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,1+L(src));
   last_pc_ = pc_;
   EMIT(0x13);
   emit_operand(dst, src);
@@ -828,7 +891,7 @@
 
 
 void Assembler::add(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,1+L(src));
   last_pc_ = pc_;
   EMIT(0x03);
   emit_operand(dst, src);
@@ -853,21 +916,21 @@
       }
     }
   }
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,5+L(dst));
   last_pc_ = pc_;
   emit_arith(0, dst, x);
 }
 
 
 void Assembler::and_(Register dst, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, Immediate(imm32).is_int8() ? 3 : 6);
   last_pc_ = pc_;
   emit_arith(4, Operand(dst), Immediate(imm32));
 }
 
 
 void Assembler::and_(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x23);
   emit_operand(dst, src);
@@ -875,14 +938,14 @@
 
 
 void Assembler::and_(const Operand& dst, const Immediate& x) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(dst));
   last_pc_ = pc_;
   emit_arith(4, dst, x);
 }
 
 
 void Assembler::and_(const Operand& dst, Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x21);
   emit_operand(src, dst);
@@ -890,7 +953,7 @@
 
 
 void Assembler::cmpb(const Operand& op, int8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(op));
   last_pc_ = pc_;
   EMIT(0x80);
   emit_operand(edi, op);  // edi == 7
@@ -900,7 +963,7 @@
 
 void Assembler::cmpb(const Operand& dst, Register src) {
   ASSERT(src.is_byte_register());
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x38);
   emit_operand(src, dst);
@@ -909,7 +972,7 @@
 
 void Assembler::cmpb(Register dst, const Operand& src) {
   ASSERT(dst.is_byte_register());
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x3A);
   emit_operand(dst, src);
@@ -928,21 +991,21 @@
 
 
 void Assembler::cmp(Register reg, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   emit_arith(7, Operand(reg), Immediate(imm32));
 }
 
 
 void Assembler::cmp(Register reg, Handle<Object> handle) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   emit_arith(7, Operand(reg), Immediate(handle));
 }
 
 
 void Assembler::cmp(Register reg, const Operand& op) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(op));
   last_pc_ = pc_;
   EMIT(0x3B);
   emit_operand(reg, op);
@@ -950,21 +1013,21 @@
 
 
 void Assembler::cmp(const Operand& op, const Immediate& imm) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(op));
   last_pc_ = pc_;
   emit_arith(7, op, imm);
 }
 
 
 void Assembler::cmp(const Operand& op, Handle<Object> handle) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(op));
   last_pc_ = pc_;
   emit_arith(7, op, Immediate(handle));
 }
 
 
 void Assembler::cmpb_al(const Operand& op) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(op));
   last_pc_ = pc_;
   EMIT(0x38);  // CMP r/m8, r8
   emit_operand(eax, op);  // eax has same code as register al.
@@ -972,7 +1035,7 @@
 
 
 void Assembler::cmpw_ax(const Operand& op) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(op));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x39);  // CMP r/m16, r16
@@ -981,7 +1044,7 @@
 
 
 void Assembler::dec_b(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xFE);
   EMIT(0xC8 | dst.code());
@@ -989,14 +1052,14 @@
 
 
 void Assembler::dec(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x48 | dst.code());
 }
 
 
 void Assembler::dec(const Operand& dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0xFF);
   emit_operand(ecx, dst);
@@ -1004,14 +1067,14 @@
 
 
 void Assembler::cdq() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x99);
 }
 
 
 void Assembler::idiv(Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF7);
   EMIT(0xF8 | src.code());
@@ -1019,7 +1082,7 @@
 
 
 void Assembler::imul(Register reg) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF7);
   EMIT(0xE8 | reg.code());
@@ -1027,7 +1090,7 @@
 
 
 void Assembler::imul(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xAF);
@@ -1036,7 +1099,7 @@
 
 
 void Assembler::imul(Register dst, Register src, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   if (is_int8(imm32)) {
     EMIT(0x6B);
@@ -1051,14 +1114,14 @@
 
 
 void Assembler::inc(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x40 | dst.code());
 }
 
 
 void Assembler::inc(const Operand& dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0xFF);
   emit_operand(eax, dst);
@@ -1066,7 +1129,7 @@
 
 
 void Assembler::lea(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x8D);
   emit_operand(dst, src);
@@ -1074,7 +1137,7 @@
 
 
 void Assembler::mul(Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF7);
   EMIT(0xE0 | src.code());
@@ -1082,7 +1145,7 @@
 
 
 void Assembler::neg(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF7);
   EMIT(0xD8 | dst.code());
@@ -1090,7 +1153,7 @@
 
 
 void Assembler::not_(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xF7);
   EMIT(0xD0 | dst.code());
@@ -1098,14 +1161,14 @@
 
 
 void Assembler::or_(Register dst, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   emit_arith(1, Operand(dst), Immediate(imm32));
 }
 
 
 void Assembler::or_(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x0B);
   emit_operand(dst, src);
@@ -1113,14 +1176,14 @@
 
 
 void Assembler::or_(const Operand& dst, const Immediate& x) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(dst));
   last_pc_ = pc_;
   emit_arith(1, dst, x);
 }
 
 
 void Assembler::or_(const Operand& dst, Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x09);
   emit_operand(src, dst);
@@ -1128,7 +1191,7 @@
 
 
 void Assembler::rcl(Register dst, uint8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3);
   last_pc_ = pc_;
   ASSERT(is_uint5(imm8));  // illegal shift count
   if (imm8 == 1) {
@@ -1143,7 +1206,7 @@
 
 
 void Assembler::sar(Register dst, uint8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3);
   last_pc_ = pc_;
   ASSERT(is_uint5(imm8));  // illegal shift count
   if (imm8 == 1) {
@@ -1158,7 +1221,7 @@
 
 
 void Assembler::sar_cl(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD3);
   EMIT(0xF8 | dst.code());
@@ -1174,7 +1237,7 @@
 
 
 void Assembler::shld(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0xA5);
@@ -1183,7 +1246,7 @@
 
 
 void Assembler::shl(Register dst, uint8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,3);
   last_pc_ = pc_;
   ASSERT(is_uint5(imm8));  // illegal shift count
   if (imm8 == 1) {
@@ -1197,8 +1260,9 @@
 }
 
 
+
 void Assembler::shl_cl(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD3);
   EMIT(0xE0 | dst.code());
@@ -1215,7 +1279,7 @@
 
 
 void Assembler::shr(Register dst, uint8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3);
   last_pc_ = pc_;
   ASSERT(is_uint5(imm8));  // illegal shift count
   if (imm8 == 1) {
@@ -1230,7 +1294,7 @@
 
 
 void Assembler::shr_cl(Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD3);
   EMIT(0xE8 | dst.code());
@@ -1251,14 +1315,14 @@
 
 
 void Assembler::sub(const Operand& dst, const Immediate& x) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,5+L(dst));
   last_pc_ = pc_;
   emit_arith(5, dst, x);
 }
 
 
 void Assembler::sub(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x2B);
   emit_operand(dst, src);
@@ -1267,7 +1331,7 @@
 
 void Assembler::subb(Register dst, const Operand& src) {
   ASSERT(dst.code() < 4);
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x2A);
   emit_operand(dst, src);
@@ -1275,7 +1339,7 @@
 
 
 void Assembler::sub(const Operand& dst, Register src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(dst));
   last_pc_ = pc_;
   EMIT(0x29);
   emit_operand(src, dst);
@@ -1283,19 +1347,23 @@
 
 
 void Assembler::test(Register reg, const Immediate& imm) {
-  EnsureSpace ensure_space(this);
-  last_pc_ = pc_;
   // Only use test against byte for registers that have a byte
   // variant: eax, ebx, ecx, and edx.
   if (imm.rmode_ == RelocInfo::NONE && is_uint8(imm.x_) && reg.code() < 4) {
     uint8_t imm8 = imm.x_;
     if (reg.is(eax)) {
+      EnsureSpace ensure_space(this, 2);
+      last_pc_ = pc_;
       EMIT(0xA8);
       EMIT(imm8);
     } else {
+      EnsureSpace ensure_space(this, 3);
+      last_pc_ = pc_;
       emit_arith_b(0xF6, 0xC0, reg, imm8);
     }
   } else {
+    EnsureSpace ensure_space(this, reg.is(eax) ? 5 : 6);
+    last_pc_ = pc_;
     // This is not using emit_arith because test doesn't support
     // sign-extension of 8-bit operands.
     if (reg.is(eax)) {
@@ -1310,7 +1378,7 @@
 
 
 void Assembler::test(Register reg, const Operand& op) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(op));
   last_pc_ = pc_;
   EMIT(0x85);
   emit_operand(reg, op);
@@ -1318,7 +1386,7 @@
 
 
 void Assembler::test_b(Register reg, const Operand& op) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(op));
   last_pc_ = pc_;
   EMIT(0x84);
   emit_operand(reg, op);
@@ -1326,7 +1394,7 @@
 
 
 void Assembler::test(const Operand& op, const Immediate& imm) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(op));
   last_pc_ = pc_;
   EMIT(0xF7);
   emit_operand(eax, op);
@@ -1335,7 +1403,7 @@
 
 
 void Assembler::test_b(const Operand& op, uint8_t imm8) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(op));
   last_pc_ = pc_;
   EMIT(0xF6);
   emit_operand(eax, op);
@@ -1344,14 +1412,14 @@
 
 
 void Assembler::xor_(Register dst, int32_t imm32) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   emit_arith(6, Operand(dst), Immediate(imm32));
 }
 
 
 void Assembler::xor_(Register dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x33);
   emit_operand(dst, src);
@@ -1359,7 +1427,7 @@
 
 
 void Assembler::xor_(const Operand& src, Register dst) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(src));
   last_pc_ = pc_;
   EMIT(0x31);
   emit_operand(dst, src);
@@ -1367,7 +1435,7 @@
 
 
 void Assembler::xor_(const Operand& dst, const Immediate& x) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5+L(dst));
   last_pc_ = pc_;
   emit_arith(6, dst, x);
 }
@@ -1392,21 +1460,25 @@
 
 
 void Assembler::hlt() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0xF4);
 }
 
 
 void Assembler::int3() {
-  EnsureSpace ensure_space(this);
+#ifdef NACL
+  hlt();
+#else
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0xCC);
+#endif
 }
 
 
 void Assembler::nop() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x90);
 }
@@ -1422,9 +1494,16 @@
 
 
 void Assembler::ret(int imm16) {
-  EnsureSpace ensure_space(this);
   last_pc_ = pc_;
   ASSERT(is_uint16(imm16));
+#if defined(NACL)
+  pop(ecx);
+  if(imm16 != 0) {
+    add(Operand(esp), Immediate(imm16));
+  }
+  jmp(Operand(ecx));
+#else
+  EnsureSpace ensure_space(this);
   if (imm16 == 0) {
     EMIT(0xC3);
   } else {
@@ -1432,6 +1511,7 @@
     EMIT(imm16 & 0xFF);
     EMIT((imm16 >> 8) & 0xFF);
   }
+#endif
 }
 
 
@@ -1468,7 +1548,7 @@
 
 
 void Assembler::bind_to(Label* L, int pos) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 0);
   last_pc_ = NULL;
   ASSERT(0 <= pos && pos <= pc_offset());  // must have a valid binding position
   while (L->is_linked()) {
@@ -1476,7 +1556,9 @@
     int fixup_pos = L->pos();
     if (disp.type() == Displacement::CODE_RELATIVE) {
       // Relative to Code* heap object pointer.
-      long_at_put(fixup_pos, pos + Code::kHeaderSize - kHeapObjectTag);
+      //NACL_CHANGE: don't include code offset in CODE_RELATIVE displacements
+      //long_at_put(fixup_pos, pos + Code::kHeaderSize - kHeapObjectTag);
+      long_at_put(fixup_pos, pos);
     } else {
       if (disp.type() == Displacement::UNCONDITIONAL_JUMP) {
         ASSERT(byte_at(fixup_pos - 1) == 0xE9);  // jmp expected
@@ -1492,7 +1574,7 @@
 
 
 void Assembler::link_to(Label* L, Label* appendix) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 0);
   last_pc_ = NULL;
   if (appendix->is_linked()) {
     if (L->is_linked()) {
@@ -1518,51 +1600,98 @@
 
 
 void Assembler::bind(Label* L) {
-  EnsureSpace ensure_space(this);
   last_pc_ = NULL;
   ASSERT(!L->is_bound());  // label can only be bound once
+  EnsureSpace ensure_space(this, 0);
   bind_to(L, pc_offset());
 }
 
+#if defined(NACL)
+void Assembler::bind_aligned(Label* L) {
+  last_pc_ = NULL;
+  ASSERT(!L->is_bound());  // label can only be bound once
+  before_bind(L);
+  EnsureSpace ensure_space(this, 0);
+  bind_to(L, pc_offset());
+}
+#endif
 
 void Assembler::call(Label* L) {
-  EnsureSpace ensure_space(this);
-  last_pc_ = pc_;
-  if (L->is_bound()) {
-    const int long_size = 5;
-    int offs = L->pos() - pc_offset();
-    ASSERT(offs <= 0);
-    // 1110 1000 #32-bit disp.
-    EMIT(0xE8);
-    emit(offs - long_size);
-  } else {
-    // 1110 1000 #32-bit disp.
-    EMIT(0xE8);
-    emit_disp(L, Displacement::OTHER);
+#if defined(NACL)
+  int offset = pc_offset() &  (NACL_CHUNK-1);
+  if(NACL_USE_CALL_THRESH <= offset && offset<NACL_CHUNK-5) {
+#endif
+    before_call(5);
+    EnsureSpace ensure_space(this,5);
+    last_pc_ = pc_;
+    if (L->is_bound()) {
+      const int long_size = 5;
+      int offs = L->pos() - pc_offset();
+      ASSERT(offs <= 0);
+      // 1110 1000 #32-bit disp.
+      EMIT(0xE8);
+      emit(offs - long_size);
+    } else {
+      // 1110 1000 #32-bit disp.
+      EMIT(0xE8);
+      emit_disp(L, Displacement::OTHER);
+    }
+#if defined(NACL)
+  }else{
+    int retaddr = push_aligned_rv(5);
+    jmp(L);
+    nops(retaddr - pc_offset());
   }
+#endif
 }
 
 
 void Assembler::call(byte* entry, RelocInfo::Mode rmode) {
-  EnsureSpace ensure_space(this);
-  last_pc_ = pc_;
   ASSERT(!RelocInfo::IsCodeTarget(rmode));
-  EMIT(0xE8);
-  emit(entry - (pc_ + sizeof(int32_t)), rmode);
+#if defined(NACL)
+  int offset = pc_offset() &  (NACL_CHUNK-1);
+  if(NACL_USE_CALL_THRESH <= offset && offset<NACL_CHUNK-5) {
+#endif
+    before_call(5);
+    EnsureSpace ensure_space(this,5);
+    last_pc_ = pc_;
+    EMIT(0xE8);
+    emit(entry - (pc_ + sizeof(int32_t)), rmode);
+#if defined(NACL)
+  }else{
+    int retaddr = push_aligned_rv(5);
+    jmp(entry, rmode);
+    nops(retaddr - pc_offset());
+  }
+#endif
 }
 
 
 void Assembler::call(const Operand& adr) {
-  EnsureSpace ensure_space(this);
-  last_pc_ = pc_;
-  EMIT(0xFF);
-  emit_operand(edx, adr);
+#if defined(NACL)
+  int offset = pc_offset() &  (NACL_CHUNK-1);
+  if(NACL_USE_CALL_THRESH <= offset && offset<NACL_CHUNK-5) {
+#endif
+    ASSERT(L(adr) == 1);
+    before_branch(adr, 5);
+    EnsureSpace ensure_space(this, 1+L(adr));
+    last_pc_ = pc_;
+    EMIT(0xFF);
+    emit_operand(edx, adr);
+#if defined(NACL)
+  }else{
+    int retaddr = push_aligned_rv(5);
+    jmp(adr);
+    nops(retaddr - pc_offset());
+  }
+#endif
 }
 
 
 void Assembler::call(Handle<Code> code, RelocInfo::Mode rmode) {
   WriteRecordedPositions();
-  EnsureSpace ensure_space(this);
+  before_call(5);
+  EnsureSpace ensure_space(this,5);
   last_pc_ = pc_;
   ASSERT(RelocInfo::IsCodeTarget(rmode));
   EMIT(0xE8);
@@ -1571,7 +1700,7 @@
 
 
 void Assembler::jmp(Label* L) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   if (L->is_bound()) {
     const int short_size = 2;
@@ -1596,7 +1725,7 @@
 
 
 void Assembler::jmp(byte* entry, RelocInfo::Mode rmode) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   ASSERT(!RelocInfo::IsCodeTarget(rmode));
   EMIT(0xE9);
@@ -1605,7 +1734,8 @@
 
 
 void Assembler::jmp(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  before_branch(adr,4+L(adr));
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xFF);
   emit_operand(esp, adr);
@@ -1613,7 +1743,7 @@
 
 
 void Assembler::jmp(Handle<Code> code, RelocInfo::Mode rmode) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   ASSERT(RelocInfo::IsCodeTarget(rmode));
   EMIT(0xE9);
@@ -1623,7 +1753,9 @@
 
 
 void Assembler::j(Condition cc, Label* L, Hint hint) {
-  EnsureSpace ensure_space(this);
+  int instsize= L->is_bound()&&is_int8(L->pos()-pc_offset()-2) ? 2 : 6;
+  instsize += FLAG_emit_branch_hints && hint != no_hint;
+  EnsureSpace ensure_space(this, instsize);
   last_pc_ = pc_;
   ASSERT(0 <= cc && cc < 16);
   if (FLAG_emit_branch_hints && hint != no_hint) EMIT(hint);
@@ -1654,7 +1786,7 @@
 
 
 void Assembler::j(Condition cc, byte* entry, RelocInfo::Mode rmode, Hint hint) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   ASSERT((0 <= cc) && (cc < 16));
   if (FLAG_emit_branch_hints && hint != no_hint) EMIT(hint);
@@ -1666,7 +1798,7 @@
 
 
 void Assembler::j(Condition cc, Handle<Code> code, Hint hint) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 6);
   last_pc_ = pc_;
   if (FLAG_emit_branch_hints && hint != no_hint) EMIT(hint);
   // 0000 1111 1000 tttn #32-bit disp
@@ -1693,7 +1825,7 @@
 
 
 void Assembler::fld1() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xE8);
@@ -1701,7 +1833,7 @@
 
 
 void Assembler::fldpi() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xEB);
@@ -1709,7 +1841,7 @@
 
 
 void Assembler::fldz() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xEE);
@@ -1717,7 +1849,7 @@
 
 
 void Assembler::fld_s(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xD9);
   emit_operand(eax, adr);
@@ -1725,7 +1857,7 @@
 
 
 void Assembler::fld_d(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDD);
   emit_operand(eax, adr);
@@ -1733,7 +1865,7 @@
 
 
 void Assembler::fstp_s(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xD9);
   emit_operand(ebx, adr);
@@ -1741,7 +1873,7 @@
 
 
 void Assembler::fstp_d(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDD);
   emit_operand(ebx, adr);
@@ -1749,7 +1881,7 @@
 
 
 void Assembler::fst_d(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDD);
   emit_operand(edx, adr);
@@ -1757,7 +1889,7 @@
 
 
 void Assembler::fild_s(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDB);
   emit_operand(eax, adr);
@@ -1765,7 +1897,7 @@
 
 
 void Assembler::fild_d(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDF);
   emit_operand(ebp, adr);
@@ -1773,7 +1905,7 @@
 
 
 void Assembler::fistp_s(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDB);
   emit_operand(ebx, adr);
@@ -1782,7 +1914,7 @@
 
 void Assembler::fisttp_s(const Operand& adr) {
   ASSERT(CpuFeatures::IsEnabled(SSE3));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDB);
   emit_operand(ecx, adr);
@@ -1791,7 +1923,7 @@
 
 void Assembler::fisttp_d(const Operand& adr) {
   ASSERT(CpuFeatures::IsEnabled(SSE3));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDD);
   emit_operand(ecx, adr);
@@ -1799,7 +1931,7 @@
 
 
 void Assembler::fist_s(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDB);
   emit_operand(edx, adr);
@@ -1807,7 +1939,7 @@
 
 
 void Assembler::fistp_d(const Operand& adr) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1+L(adr));
   last_pc_ = pc_;
   EMIT(0xDF);
   emit_operand(edi, adr);
@@ -1815,7 +1947,7 @@
 
 
 void Assembler::fabs() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xE1);
@@ -1823,7 +1955,7 @@
 
 
 void Assembler::fchs() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xE0);
@@ -1831,7 +1963,7 @@
 
 
 void Assembler::fcos() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xFF);
@@ -1839,7 +1971,7 @@
 
 
 void Assembler::fsin() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xFE);
@@ -1941,7 +2073,7 @@
 
 
 void Assembler::fincstp() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xF7);
@@ -1949,14 +2081,14 @@
 
 
 void Assembler::ffree(int i) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   emit_farith(0xDD, 0xC0, i);
 }
 
 
 void Assembler::ftst() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xE4);
@@ -1971,7 +2103,7 @@
 
 
 void Assembler::fucompp() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xDA);
   EMIT(0xE9);
@@ -1979,7 +2111,7 @@
 
 
 void Assembler::fucomi(int i) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xDB);
   EMIT(0xE8 + i);
@@ -1987,7 +2119,7 @@
 
 
 void Assembler::fucomip() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xDF);
   EMIT(0xE9);
@@ -1995,7 +2127,7 @@
 
 
 void Assembler::fcompp() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xDE);
   EMIT(0xD9);
@@ -2003,7 +2135,7 @@
 
 
 void Assembler::fnstsw_ax() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xDF);
   EMIT(0xE0);
@@ -2011,14 +2143,14 @@
 
 
 void Assembler::fwait() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x9B);
 }
 
 
 void Assembler::frndint() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xD9);
   EMIT(0xFC);
@@ -2026,7 +2158,7 @@
 
 
 void Assembler::fnclex() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2);
   last_pc_ = pc_;
   EMIT(0xDB);
   EMIT(0xE2);
@@ -2034,7 +2166,7 @@
 
 
 void Assembler::sahf() {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 1);
   last_pc_ = pc_;
   EMIT(0x9E);
 }
@@ -2042,7 +2174,7 @@
 
 void Assembler::setcc(Condition cc, Register reg) {
   ASSERT(reg.is_byte_register());
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3);
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0x90 | cc);
@@ -2052,7 +2184,7 @@
 
 void Assembler::cvttss2si(Register dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0xF3);
   EMIT(0x0F);
@@ -2063,7 +2195,7 @@
 
 void Assembler::cvttsd2si(Register dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2074,7 +2206,7 @@
 
 void Assembler::cvtsi2sd(XMMRegister dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2085,7 +2217,7 @@
 
 void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF3);
   EMIT(0x0F);
@@ -2096,7 +2228,7 @@
 
 void Assembler::addsd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2107,7 +2239,7 @@
 
 void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2118,7 +2250,7 @@
 
 void Assembler::subsd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2129,7 +2261,7 @@
 
 void Assembler::divsd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2140,7 +2272,7 @@
 
 void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2150,7 +2282,7 @@
 
 
 void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2161,7 +2293,7 @@
 
 void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2172,7 +2304,7 @@
 
 void Assembler::movmskpd(Register dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2183,7 +2315,7 @@
 
 void Assembler::movdqa(const Operand& dst, XMMRegister src ) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(dst));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2194,7 +2326,7 @@
 
 void Assembler::movdqa(XMMRegister dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2205,7 +2337,7 @@
 
 void Assembler::movdqu(const Operand& dst, XMMRegister src ) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(dst));
   last_pc_ = pc_;
   EMIT(0xF3);
   EMIT(0x0F);
@@ -2216,7 +2348,7 @@
 
 void Assembler::movdqu(XMMRegister dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0xF3);
   EMIT(0x0F);
@@ -2227,7 +2359,7 @@
 
 void Assembler::movntdqa(XMMRegister dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE4_1));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4+L(src));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2239,7 +2371,7 @@
 
 void Assembler::movntdq(const Operand& dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(dst));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2250,7 +2382,7 @@
 
 void Assembler::prefetch(const Operand& src, int level) {
   ASSERT(is_uint2(level));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 2+L(src));
   last_pc_ = pc_;
   EMIT(0x0F);
   EMIT(0x18);
@@ -2260,14 +2392,14 @@
 
 
 void Assembler::movdbl(XMMRegister dst, const Operand& src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,3+L(src));
   last_pc_ = pc_;
   movsd(dst, src);
 }
 
 
 void Assembler::movdbl(const Operand& dst, XMMRegister src) {
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this,3+L(dst));
   last_pc_ = pc_;
   movsd(dst, src);
 }
@@ -2275,7 +2407,7 @@
 
 void Assembler::movsd(const Operand& dst, XMMRegister src ) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(dst));
   last_pc_ = pc_;
   EMIT(0xF2);  // double
   EMIT(0x0F);
@@ -2286,7 +2418,7 @@
 
 void Assembler::movsd(XMMRegister dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0xF2);  // double
   EMIT(0x0F);
@@ -2296,7 +2428,7 @@
 
 void Assembler::movsd(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0xF2);
   EMIT(0x0F);
@@ -2307,7 +2439,7 @@
 
 void Assembler::movd(XMMRegister dst, const Operand& src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 3+L(src));
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2318,7 +2450,7 @@
 
 void Assembler::pxor(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 4);
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2329,7 +2461,7 @@
 
 void Assembler::ptest(XMMRegister dst, XMMRegister src) {
   ASSERT(CpuFeatures::IsEnabled(SSE2));
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 5);
   last_pc_ = pc_;
   EMIT(0x66);
   EMIT(0x0F);
@@ -2361,21 +2493,21 @@
 
 void Assembler::RecordJSReturn() {
   WriteRecordedPositions();
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 0);
   RecordRelocInfo(RelocInfo::JS_RETURN);
 }
 
 
 void Assembler::RecordDebugBreakSlot() {
   WriteRecordedPositions();
-  EnsureSpace ensure_space(this);
+  EnsureSpace ensure_space(this, 0);
   RecordRelocInfo(RelocInfo::DEBUG_BREAK_SLOT);
 }
 
 
 void Assembler::RecordComment(const char* msg) {
   if (FLAG_debug_code) {
-    EnsureSpace ensure_space(this);
+    EnsureSpace ensure_space(this, 0);
     RecordRelocInfo(RelocInfo::COMMENT, reinterpret_cast<intptr_t>(msg));
   }
 }
@@ -2401,7 +2533,7 @@
   // Write the statement position if it is different from what was written last
   // time.
   if (current_statement_position_ != written_statement_position_) {
-    EnsureSpace ensure_space(this);
+    EnsureSpace ensure_space(this, 0);
     RecordRelocInfo(RelocInfo::STATEMENT_POSITION, current_statement_position_);
     written_statement_position_ = current_statement_position_;
     written = true;
@@ -2411,7 +2543,7 @@
   // also different from the written statement position.
   if (current_position_ != written_position_ &&
       current_position_ != written_statement_position_) {
-    EnsureSpace ensure_space(this);
+    EnsureSpace ensure_space(this, 0);
     RecordRelocInfo(RelocInfo::POSITION, current_position_);
     written_position_ = current_position_;
     written = true;
@@ -2447,7 +2579,8 @@
 
   // Clear the buffer in debug mode. Use 'int3' instructions to make
   // sure to get into problems if we ever run uninitialized code.
-#ifdef DEBUG
+#if defined(DEBUG) || defined(NACL)
+  //TODO(jansel): why does nacl need this?
   memset(desc.buffer, 0xCC, desc.buffer_size);
 #endif
 
@@ -2552,7 +2685,154 @@
   emit(data, reloc_info);
 }
 
+void Assembler::before(int maxsize) {
+#ifdef NACL
+  int left = NACL_CHUNK - (pc_offset()&(NACL_CHUNK-1));
+  if(left < maxsize) {
+    nops(left);
+  }
+#endif
+}
 
+void Assembler::before_call(int n) {
+#if defined(NACL)
+  int left = NACL_CHUNK - (pc_offset()&(NACL_CHUNK-1));
+  if(left >= n) {
+    nops(left-n);
+  }else{
+    //scroll to next chunk and start over
+    nops(left);
+    before_call(n);
+  }
+#endif
+}
+
+void Assembler::before_branch(const Operand& op, int maxsize) {
+#if defined(NACL)
+  //hack since cant convert op to reg
+  Register r;
+  for(int i=0; i<8; ++i){
+    r.code_ = i;
+    if(op.is_reg(r)){
+#if defined(DEBUG) && 0
+      //verify target is aligned 
+      Label ok;
+      push(r);
+      and_(r, NACL_CHUNK-1);
+      j(zero, &ok);
+      int3();
+      bind(&ok);
+      pop(r);
+#endif
+      if(maxsize>0){
+        before_call(maxsize);
+      }
+      //required by nacl:
+      and_(r, ~(NACL_CHUNK-1));
+      return;
+    }
+  }
+#endif
+}
+
+void Assembler::before_bind(Label* L) {
+#ifdef NACL
+#if 0 //turns out this is slower
+
+  if(L->is_linked()) {
+    if (disp_at(L).type() == Displacement::CODE_RELATIVE) {
+      //code relative 
+      Align(NACL_CHUNK);
+      return;
+    } else {
+      //pc relative
+      if(pc_offset()>>5 != L->pos()>>5) {
+        //diff bundles
+        Align(NACL_CHUNK);
+        return;
+      }
+    }
+  } else { 
+    Align(NACL_CHUNK);
+    return;
+  }
+
+#else
+  Align(NACL_CHUNK);
+#endif
+#endif
+}
+
+#ifdef NACL
+int Assembler::push_aligned_rv(int space) {
+  int bundle = pc_offset() & ~(NACL_CHUNK-1);
+  int offset = pc_offset() &  (NACL_CHUNK-1);
+  int retaddr;
+  if(offset <= NACL_CHUNK-5-space) {
+    //will fit in this bundle
+    retaddr = bundle + NACL_CHUNK;
+  }else{
+    //will spill to next bundle
+    retaddr = bundle + NACL_CHUNK + NACL_CHUNK;
+  }
+  { EnsureSpace ensure_space(this,5);
+    push(buffer_+retaddr, RelocInfo::INTERNAL_REFERENCE);
+  }
+  return retaddr;
+}
+#endif
+  
+void Assembler::nops(int n) {
+  ASSERT(n>=0 && n<32);
+  EnsureSpace ensure_space(this, n);
+  last_pc_ = NULL;
+
+  if(n>20) {
+    n -= 2;
+    //2 byte jmp
+    EMIT(0xEB);
+    EMIT(n);
+  }
+  static const uint8_t opt_nop01[] = {0x90, 0};
+  static const uint8_t opt_nop02[] = {0x66, 0x90, 0};
+  static const uint8_t opt_nop03[] = {0x66, 0x87, 0xc9, 0};
+  static const uint8_t opt_nop04[] = {0x66, 0x90, 0x66, 0x90, 0};
+  static const uint8_t opt_nop05[] = {0x90, 0x8d, 0x7c, 0x27, 0x00, 0};
+  static const uint8_t opt_nop06[] = {0x66, 0x90, 0x8d, 0x76, 0x00, 0x90, 0};
+  static const uint8_t opt_nop07[] = {0x8d, 0x76, 0x00, 0x8d, 0x7c, 0x27, 0x00, 0};
+  static const uint8_t opt_nop08[] = {0x66, 0x90, 0x89, 0xf6, 0x8d, 0x7c, 0x27, 0x00, 0};
+  static const uint8_t opt_nop09[] = {0x8d, 0x76, 0x00, 0x89, 0xf6, 0x8d, 0x74, 0x26, 0x00, 0};
+  static const uint8_t opt_nop10[] = {0x8d, 0x74, 0x26, 0x00, 0x66, 0x90, 0x8d, 0x74, 0x26, 0x00, 0};
+  static const uint8_t opt_nop11[] = {0x89, 0xf6, 0x90, 0x8d, 0x74, 0x26, 0x00, 0x8d, 0x7c, 0x27, 0x00, 0};
+  static const uint8_t opt_nop12[] = {0x66, 0x90, 0x8d, 0x76, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop13[] = {0x90, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8d, 0x74, 0x26, 0x00, 0};
+  static const uint8_t opt_nop14[] = {0x66, 0x90, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8d, 0x74, 0x26, 0x00, 0};
+  static const uint8_t opt_nop15[] = {0x89, 0xf6, 0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop16[] = {0x89, 0xf6, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x66, 0x90, 0};
+  static const uint8_t opt_nop17[] = {0x89, 0xf6, 0x8d, 0x7c, 0x27, 0x00, 0x8d, 0x74, 0x26, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop18[] = {0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8d, 0x74, 0x26, 0x00, 0};
+  static const uint8_t opt_nop19[] = {0x8d, 0x7c, 0x27, 0x00, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x66, 0x90, 0};
+  static const uint8_t opt_nop20[] = {0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop21[] = {0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x76, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x7c, 0x27, 0x00, 0};
+  static const uint8_t opt_nop22[] = {0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x66, 0x90, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop23[] = {0x0f, 0x1f, 0x00, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop24[] = {0x90, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x74, 0x26, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop25[] = {0x87, 0xc9, 0x8d, 0x76, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop26[] = {0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8d, 0x74, 0x26, 0x00, 0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop27[] = {0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x66, 0x87, 0xd2, 0x8d, 0x74, 0x26, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop28[] = {0x8d, 0x76, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x76, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop29[] = {0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x90, 0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop30[] = {0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x76, 0x00, 0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+  static const uint8_t opt_nop31[] = {0x8d, 0xb6, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xb4, 0x26, 0x00, 0x00, 0x00, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0x8d, 0x74, 0x26, 0x00, 0x8d, 0xbc, 0x27, 0x00, 0x00, 0x00, 0x00, 0};
+
+  if(n>0) {
+   static const uint8_t* opt_nops[] = {opt_nop01, opt_nop02, opt_nop03, opt_nop04, opt_nop05, opt_nop06, opt_nop07, opt_nop08, opt_nop09, opt_nop10, opt_nop11, opt_nop12, opt_nop13, opt_nop14, opt_nop15, opt_nop16, opt_nop17, opt_nop18, opt_nop19, opt_nop20, opt_nop21, opt_nop22, opt_nop23, opt_nop24, opt_nop25, opt_nop26, opt_nop27, opt_nop28, opt_nop29, opt_nop30, opt_nop31, 0};
+    memcpy(pc_, opt_nops[n-1], n);
+    pc_+=n;
+  }
+
+}
+
 void Assembler::RecordRelocInfo(RelocInfo::Mode rmode, intptr_t data) {
   ASSERT(rmode != RelocInfo::NONE);
   // Don't record external references unless the heap will be serialized.
Index: src/ia32/stub-cache-ia32.cc
===================================================================
--- src/ia32/stub-cache-ia32.cc	(revision 4925)
+++ src/ia32/stub-cache-ia32.cc	(working copy)
@@ -66,6 +66,7 @@
 
     // Jump to the first instruction in the code stub.
     __ add(Operand(extra), Immediate(Code::kHeaderSize - kHeapObjectTag));
+    NACL_PATCH_INSTRUCTION_START(extra);
     __ jmp(Operand(extra));
 
     __ bind(&miss);
@@ -92,6 +93,7 @@
 
     // Jump to the first instruction in the code stub.
     __ add(Operand(offset), Immediate(Code::kHeaderSize - kHeapObjectTag));
+    NACL_PATCH_INSTRUCTION_START(offset);
     __ jmp(Operand(offset));
 
     // Pop at miss.
@@ -1039,6 +1041,7 @@
 
   // Do a tail-call of the compiled function.
   __ lea(ecx, FieldOperand(eax, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(ecx);
   __ jmp(Operand(ecx));
 
   return GetCodeWithFlags(flags, "LazyCompileStub");
Index: src/ia32/assembler-ia32.h
===================================================================
--- src/ia32/assembler-ia32.h	(revision 4925)
+++ src/ia32/assembler-ia32.h	(working copy)
@@ -37,6 +37,14 @@
 #ifndef V8_IA32_ASSEMBLER_IA32_H_
 #define V8_IA32_ASSEMBLER_IA32_H_
 
+
+//NACL_CHANGE: patch output code to use separate code location
+#ifdef NACL
+#define NACL_CHUNK 32
+#endif
+#define NACL_PATCH_INSTRUCTION_START(reg) \
+  __ mov(reg, Operand(reg, Code::kExternalInstructionsOffset-Code::kHeaderSize))
+
 #include "serialize.h"
 
 namespace v8 {
@@ -421,7 +429,11 @@
   // (There is a 15 byte limit on ia32 instruction length that rules out some
   // otherwise valid instructions.)
   // This allows for a single, fast space check per instruction.
+#ifdef NACL
+  static const int kGap = 64;
+#else
   static const int kGap = 32;
+#endif
 
  public:
   // Create an assembler. Instructions and relocation information are emitted
@@ -447,7 +459,7 @@
 
   // Read/Modify the code target in the branch/call instruction at pc.
   inline static Address target_address_at(Address pc);
-  inline static void set_target_address_at(Address pc, Address target);
+  inline static void set_target_address_at(Address pc, Address target, intptr_t extraoffset = 0);
 
   // This sets the branch destination (which is in the instruction on x86).
   // This is for calls and branches within generated code.
@@ -478,7 +490,11 @@
   static const int kPatchDebugBreakSlotAddressOffset = 1;  // JMP imm32.
 
   static const int kCallInstructionLength = 5;
+#ifdef NACL
+  static const int kJSReturnSequenceLength = NACL_CHUNK;
+#else
   static const int kJSReturnSequenceLength = 6;
+#endif
 
   // The debug break slot must be able to contain a call instruction.
   static const int kDebugBreakSlotLength = kCallInstructionLength;
@@ -521,6 +537,7 @@
   void push(Register src);
   void push(const Operand& src);
   void push(Label* label, RelocInfo::Mode relocation_mode);
+  void push(byte* x, RelocInfo::Mode rmode);
 
   void pop(Register dst);
   void pop(const Operand& dst);
@@ -685,6 +702,9 @@
   // but it may be bound only once.
 
   void bind(Label* L);  // binds an unbound label L to the current code position
+#if defined(NACL)
+  void bind_aligned(Label *L);
+#endif
 
   // Calls
   void call(Label* L);
@@ -851,6 +871,22 @@
 
   static bool IsNop(Address addr) { return *addr == 0x90; }
 
+  //NACL_CHANGE: call before each instruction
+  void before(int maxsize);
+  
+  //NACL_CHANGE: call before each branch instruction
+  void before_branch(const Operand& op, int maxsize=-1);
+  
+  //NACL_CHANGE: call before each call instruction
+  void before_call(int size);
+  
+  //NACL_CHANGE: call before bind
+  void before_bind(Label* l);
+
+  int push_aligned_rv(int space);
+  
+  void nops(int n);
+
   // Avoid overflows for displacements etc.
   static const int kMaximalBufferSize = 512*MB;
   static const int kMinimalBufferSize = 4*KB;
@@ -943,10 +979,19 @@
 // checks that we did not generate too much.
 class EnsureSpace BASE_EMBEDDED {
  public:
-  explicit EnsureSpace(Assembler* assembler) : assembler_(assembler) {
+  explicit EnsureSpace(Assembler* assembler, int maxinst = 15) : assembler_(assembler) {
+#ifndef NACL
     if (assembler_->overflow()) assembler_->GrowBuffer();
+    USE(maxinst);
+#else
+    if(maxinst > 1) {
+      assembler_->before(maxinst); 
+    }
+    if (assembler_->overflow()) assembler_->GrowBuffer();
+#endif
 #ifdef DEBUG
     space_before_ = assembler_->available_space();
+    max_pc_offset_after_ = assembler_->pc_offset() + maxinst;
 #endif
   }
 
@@ -954,6 +999,9 @@
   ~EnsureSpace() {
     int bytes_generated = space_before_ - assembler_->available_space();
     ASSERT(bytes_generated < assembler_->kGap);
+    ASSERT(assembler_->pc_offset() <= max_pc_offset_after_);
+    //asserts the quality of our size predictions by bounding waste:
+    //ASSERT(max_pc_offset_after_ - assembler_->pc_offset() <= 3);
   }
 #endif
 
@@ -961,6 +1009,7 @@
   Assembler* assembler_;
 #ifdef DEBUG
   int space_before_;
+  int max_pc_offset_after_;
 #endif
 };
 
Index: src/ia32/debug-ia32.cc
===================================================================
--- src/ia32/debug-ia32.cc	(revision 4925)
+++ src/ia32/debug-ia32.cc	(working copy)
@@ -141,7 +141,11 @@
   // overwritten by the address of DebugBreakXXX.
   ExternalReference after_break_target =
       ExternalReference(Debug_Address::AfterBreakTarget());
+#ifdef NACL
+  __ hlt(); // cant support this :(
+#else
   __ jmp(Operand::StaticVariable(after_break_target));
+#endif
 }
 
 
@@ -280,7 +284,9 @@
   __ mov(edx, FieldOperand(edi, JSFunction::kSharedFunctionInfoOffset));
   __ mov(edx, FieldOperand(edx, SharedFunctionInfo::kCodeOffset));
   __ lea(edx, FieldOperand(edx, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(edx);
 
+
   // Re-run JSFunction, edi is function, esi is context.
   __ jmp(Operand(edx));
 }
Index: src/ia32/cpu-ia32.cc
===================================================================
--- src/ia32/cpu-ia32.cc	(revision 4925)
+++ src/ia32/cpu-ia32.cc	(working copy)
@@ -73,6 +73,8 @@
   // instead
   // __asm { int 3 }
   __debugbreak();
+#elif defined(NACL)
+  asm("hlt");
 #else
   asm("int $3");
 #endif
Index: src/ia32/builtins-ia32.cc
===================================================================
--- src/ia32/builtins-ia32.cc	(revision 4925)
+++ src/ia32/builtins-ia32.cc	(working copy)
@@ -90,6 +90,7 @@
   __ mov(ebx, FieldOperand(edi, JSFunction::kSharedFunctionInfoOffset));
   __ mov(ebx, FieldOperand(ebx, SharedFunctionInfo::kConstructStubOffset));
   __ lea(ebx, FieldOperand(ebx, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(ebx);
   __ jmp(Operand(ebx));
 
   // edi: called object
@@ -550,6 +551,7 @@
   __ SmiUntag(ebx);
   __ mov(edx, FieldOperand(edx, SharedFunctionInfo::kCodeOffset));
   __ lea(edx, FieldOperand(edx, Code::kHeaderSize));
+  NACL_PATCH_INSTRUCTION_START(edx);
   __ cmp(eax, Operand(ebx));
   __ j(not_equal, Handle<Code>(builtin(ArgumentsAdaptorTrampoline)));
 
Index: src/ia32/ic-ia32.cc
===================================================================
--- src/ia32/ic-ia32.cc	(revision 4925)
+++ src/ia32/ic-ia32.cc	(working copy)
@@ -34,6 +34,9 @@
 #include "runtime.h"
 #include "stub-cache.h"
 #include "utils.h"
+#ifdef NACL
+#include "naclcode.h"
+#endif
 
 namespace v8 {
 namespace internal {
@@ -257,7 +260,11 @@
 // The offset from the inlined patch site to the start of the
 // inlined load instruction.  It is 7 bytes (test eax, imm) plus
 // 6 bytes (jne slow_label).
+#if defined(NACL) && NACL_CHUNK == 16
+const int LoadIC::kOffsetToLoadInstruction = 16;
+#else
 const int LoadIC::kOffsetToLoadInstruction = 13;
+#endif
 
 
 void LoadIC::GenerateArrayLength(MacroAssembler* masm) {
@@ -1656,14 +1663,22 @@
   // operand-immediate compare instruction, so we add 3 to get the
   // offset to the last 4 bytes.
   Address map_address = test_instruction_address + delta + 3;
+#ifdef NACL
+  NaClCode::PatchWord(reinterpret_cast<Object**>(map_address), map);
+#else
   *(reinterpret_cast<Object**>(map_address)) = map;
+#endif
 
   // The offset is in the last 4 bytes of a six byte
   // memory-to-register move instruction, so we add 2 to get the
   // offset to the last 4 bytes.
   Address offset_address =
       test_instruction_address + delta + kOffsetToLoadInstruction + 2;
+#ifdef NACL
+  NaClCode::PatchWord(reinterpret_cast<int*>(offset_address), offset - kHeapObjectTag);
+#else
   *reinterpret_cast<int*>(offset_address) = offset - kHeapObjectTag;
+#endif
   return true;
 }
 
@@ -1685,7 +1700,11 @@
   // to the offset to get the map address.
   Address map_address = test_instruction_address + delta + 3;
   // Patch the map check.
+#ifdef NACL
+  NaClCode::PatchWord(reinterpret_cast<Object**>(map_address), map);
+#else
   *(reinterpret_cast<Object**>(map_address)) = map;
+#endif
   return true;
 }
 
Index: src/platform-nullos.cc
===================================================================
--- src/platform-nullos.cc	(revision 4925)
+++ src/platform-nullos.cc	(working copy)
@@ -137,14 +137,14 @@
   vfprintf(stderr, format, args);
 }
 
-
-int OS::SNPrintF(char* str, size_t size, const char* format, ...) {
+int OS::SNPrintF(Vector<char> str, const char* format, ...) {
   UNIMPLEMENTED();
   return 0;
 }
 
-
-int OS::VSNPrintF(char* str, size_t size, const char* format, va_list args) {
+int OS::VSNPrintF(Vector<char> str,
+                  const char* format,
+                  va_list args) {
   UNIMPLEMENTED();
   return 0;
 }
@@ -163,6 +163,7 @@
 
 bool OS::ArmCpuHasFeature(CpuFeature feature) {
   UNIMPLEMENTED();
+  return false;
 }
 
 
@@ -240,7 +241,7 @@
 }
 
 
-VirtualMemory::VirtualMemory(size_t size, void* address_hint) {
+VirtualMemory::VirtualMemory(size_t size) {
   UNIMPLEMENTED();
 }
 
@@ -401,6 +402,11 @@
     UNIMPLEMENTED();
   }
 
+  virtual bool Wait(int timeout) {
+    UNIMPLEMENTED();
+    return false;
+  }
+
   virtual void Signal() {
     UNIMPLEMENTED();
   }
@@ -416,6 +422,9 @@
 
 #ifdef ENABLE_LOGGING_AND_PROFILING
 
+/*
+//ProfileSampler no longer seems to exist...
+
 class ProfileSampler::PlatformData  : public Malloced {
  public:
   PlatformData() {
@@ -449,6 +458,8 @@
   UNIMPLEMENTED();
 }
 
+*/
+
 #endif  // ENABLE_LOGGING_AND_PROFILING
 
 } }  // namespace v8::internal
Index: src/jsregexp.h
===================================================================
--- src/jsregexp.h	(revision 4925)
+++ src/jsregexp.h	(working copy)
@@ -114,7 +114,7 @@
   static IrregexpResult IrregexpExecOnce(Handle<JSRegExp> regexp,
                                          Handle<String> subject,
                                          int index,
-                                         Vector<int32_t> registers);
+                                         Vector<int> registers);
 
   // Execute an Irregexp bytecode pattern.
   // On a successful match, the result is a JSArray containing
Index: src/platform-nacl.cc
===================================================================
--- src/platform-nacl.cc	(revision 0)
+++ src/platform-nacl.cc	(revision 0)
@@ -0,0 +1,488 @@
+// Copyright 2006-2008 the V8 project authors. All rights reserved.
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+//       copyright notice, this list of conditions and the following
+//       disclaimer in the documentation and/or other materials provided
+//       with the distribution.
+//     * Neither the name of Google Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// Platform specific code for Native Client goes here
+
+#include <errno.h>
+#include <pthread.h>
+#include <sched.h>
+#include <semaphore.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sys/time.h>
+#include <sys/mman.h>
+#include <stdarg.h>
+
+#include "v8.h"
+#include "platform.h"
+
+namespace v8 {
+namespace internal {
+
+// NACL doesn't yet support _SC_PAGESIZE
+static const size_t kNaclPageSize = 0x10000;
+
+// 0 is never a valid thread id on Linux since tids and pids share a
+// name space and pid 0 is reserved (see man 2 kill).
+static const pthread_t kNoThread = (pthread_t) 0;
+
+// Give V8 the opportunity to override the default ceil behaviour.
+double ceiling(double x) {
+  return ceil(x);
+}
+
+// Initialize OS class early in the V8 startup.
+void OS::Setup() {
+  //NACL does yet support srandom() so use srand() instead
+  uint64_t seed = static_cast<uint64_t>(TimeCurrentMillis());
+  srand(static_cast<unsigned int>(seed));
+}
+
+// Returns the accumulated user time for thread.
+int OS::GetUserTime(uint32_t* secs,  uint32_t* usecs) {
+  UNIMPLEMENTED();
+  *secs = 0;
+  *usecs = 0;
+  return 0;
+}
+
+// Returns a string identifying the current timezone taking into
+// account daylight saving.
+const char* OS::LocalTimezone(double time) {
+  return "<none>";
+}
+
+// Returns the local time offset in milliseconds east of UTC without
+// taking daylight savings time into account.
+double OS::LocalTimeOffset() {
+  return 0;
+}
+
+int OS::SNPrintF(Vector<char> str, const char* format, ...) {
+  va_list args;
+  va_start(args, format);
+  int n = vsprintf(str.start(), format, args);
+  va_end(args);
+  return n;
+}
+
+int OS::VSNPrintF(Vector<char> str,
+                  const char* format,
+                  va_list args) {
+  //*THIS IS BAD*
+  // NACL doesn't support vsnprintf, so we ignore size of buffer
+  return vsprintf(str.start(), format, args);
+}
+
+
+uint64_t OS::CpuFeaturesImpliedByPlatform() {
+  return 0;
+}
+
+bool OS::ArmCpuHasFeature(CpuFeature feature) {
+  UNIMPLEMENTED();
+  return false;
+}
+
+// We keep the lowest and highest addresses mapped as a quick way of
+// determining that pointers are outside the heap (used mostly in assertions
+// and verification).  The estimate is conservative, ie, not all addresses in
+// 'allocated' space are actually allocated to our heap.  The range is
+// [lowest, highest), inclusive on the low and and exclusive on the high end.
+static void* lowest_ever_allocated = reinterpret_cast<void*>(-1);
+static void* highest_ever_allocated = reinterpret_cast<void*>(0);
+
+static void UpdateAllocatedSpaceLimits(void* address, int size) {
+  lowest_ever_allocated = Min(lowest_ever_allocated, address);
+  highest_ever_allocated =
+      Max(highest_ever_allocated,
+          reinterpret_cast<void*>(reinterpret_cast<char*>(address) + size));
+}
+
+bool OS::IsOutsideAllocatedSpace(void* address) {
+  return address < lowest_ever_allocated || address >= highest_ever_allocated;
+}
+
+size_t OS::AllocateAlignment() {
+  return kNaclPageSize;
+}
+
+void* OS::Allocate(const size_t requested,
+                   size_t* allocated,
+                   bool is_executable) {
+  const size_t msize = RoundUp(requested, kNaclPageSize);
+  int prot = PROT_READ | PROT_WRITE;
+  void* mbase = mmap(NULL, msize, prot, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  if (mbase == MAP_FAILED) {
+    LOG(StringEvent("OS::Allocate", "mmap failed"));
+    return NULL;
+  }
+  *allocated = msize;
+  UpdateAllocatedSpaceLimits(mbase, msize);
+  return mbase;
+}
+
+
+void OS::Free(void* buf, const size_t length) {
+  const size_t msize = RoundUp(length, kNaclPageSize);
+  int rv = munmap(buf, msize);
+  if (rv != 0) {
+    LOG(StringEvent("OS::Free", "munmap failed"));
+  }
+}
+
+
+#ifdef ENABLE_HEAP_PROTECTION
+
+void OS::Protect(void* address, size_t size) {
+  UNIMPLEMENTED();
+}
+
+
+void OS::Unprotect(void* address, size_t size, bool is_executable) {
+  UNIMPLEMENTED();
+}
+
+#endif
+
+
+void OS::Sleep(int milliseconds) {
+  UNIMPLEMENTED();
+}
+
+void OS::Abort() {
+#ifdef DEBUG
+  static int* invalid = reinterpret_cast<int*>(0);
+  *invalid=1;//force debugger to stop without int3
+#endif
+  asm ( "hlt" );
+}
+
+void OS::DebugBreak() {
+  Abort();
+}
+
+OS::MemoryMappedFile* OS::MemoryMappedFile::create(const char* name, int size,
+    void* initial) {
+  UNIMPLEMENTED();
+  return NULL;
+}
+
+
+void OS::LogSharedLibraryAddresses() {
+  UNIMPLEMENTED();
+}
+
+
+int OS::StackWalk(Vector<OS::StackFrame> frames) {
+  UNIMPLEMENTED();
+  return 0;
+}
+
+// Constants used for mmap.
+static const int kMmapFd = -1;
+static const int kMmapFdOffset = 0;
+
+VirtualMemory::VirtualMemory(size_t size) {
+  address_ = mmap(NULL, size, PROT_NONE,
+                  MAP_PRIVATE | MAP_ANONYMOUS,
+                  kMmapFd, kMmapFdOffset);
+  size_ = size;
+}
+
+VirtualMemory::~VirtualMemory() {
+  if (IsReserved()) {
+    if (0 == munmap(address(), size())) address_ = MAP_FAILED;
+  }
+}
+
+bool VirtualMemory::IsReserved() {
+  return address_ != MAP_FAILED;
+}
+
+bool VirtualMemory::Commit(void* address, size_t size, bool is_executable) {
+  int prot = PROT_READ | PROT_WRITE | (is_executable ? PROT_EXEC : 0);
+  if (MAP_FAILED == mmap(address, size, prot,
+                         MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
+                         kMmapFd, kMmapFdOffset)) {
+    return false;
+  }
+
+  UpdateAllocatedSpaceLimits(address, size);
+  return true;
+}
+
+
+bool VirtualMemory::Uncommit(void* address, size_t size) {
+  return mmap(address, size, PROT_NONE,
+              MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,
+              kMmapFd, kMmapFdOffset) != MAP_FAILED;
+}
+
+class ThreadHandle::PlatformData : public Malloced {
+ public:
+  explicit PlatformData(ThreadHandle::Kind kind) {
+    Initialize(kind);
+  }
+
+  void Initialize(ThreadHandle::Kind kind) {
+    switch (kind) {
+      case ThreadHandle::SELF: thread_ = pthread_self(); break;
+      case ThreadHandle::INVALID: thread_ = kNoThread; break;
+    }
+  }
+
+  pthread_t thread_;  // Thread handle for pthread.
+};
+
+
+ThreadHandle::ThreadHandle(Kind kind) {
+  data_ = new PlatformData(kind);
+}
+
+
+void ThreadHandle::Initialize(ThreadHandle::Kind kind) {
+  data_->Initialize(kind);
+}
+
+
+ThreadHandle::~ThreadHandle() {
+  delete data_;
+}
+
+
+bool ThreadHandle::IsSelf() const {
+  return pthread_equal(data_->thread_, pthread_self());
+}
+
+
+bool ThreadHandle::IsValid() const {
+  return data_->thread_ != kNoThread;
+}
+
+
+Thread::Thread() : ThreadHandle(ThreadHandle::INVALID) {
+}
+
+
+Thread::~Thread() {
+}
+
+
+static void* ThreadEntry(void* arg) {
+  Thread* thread = reinterpret_cast<Thread*>(arg);
+  // This is also initialized by the first argument to pthread_create() but we
+  // don't know which thread will run first (the original thread or the new
+  // one) so we initialize it here too.
+  thread->thread_handle_data()->thread_ = pthread_self();
+  ASSERT(thread->IsValid());
+  thread->Run();
+  return NULL;
+}
+
+
+void Thread::Start() {
+  pthread_create(&thread_handle_data()->thread_, NULL, ThreadEntry, this);
+  ASSERT(IsValid());
+}
+
+
+void Thread::Join() {
+  pthread_join(thread_handle_data()->thread_, NULL);
+}
+
+
+Thread::LocalStorageKey Thread::CreateThreadLocalKey() {
+  pthread_key_t key;
+  int result = pthread_key_create(&key, NULL);
+  USE(result);
+  ASSERT(result == 0);
+  return static_cast<LocalStorageKey>(key);
+}
+
+
+void Thread::DeleteThreadLocalKey(LocalStorageKey key) {
+  pthread_key_t pthread_key = static_cast<pthread_key_t>(key);
+  int result = pthread_key_delete(pthread_key);
+  USE(result);
+  ASSERT(result == 0);
+}
+
+
+void* Thread::GetThreadLocal(LocalStorageKey key) {
+  pthread_key_t pthread_key = static_cast<pthread_key_t>(key);
+  return pthread_getspecific(pthread_key);
+}
+
+
+void Thread::SetThreadLocal(LocalStorageKey key, void* value) {
+  pthread_key_t pthread_key = static_cast<pthread_key_t>(key);
+  pthread_setspecific(pthread_key, value);
+}
+
+
+void Thread::YieldCPU() {
+  sched_yield();
+}
+
+class LinuxMutex : public Mutex {
+ public:
+
+  LinuxMutex() {
+    pthread_mutexattr_t attrs;
+    int result = pthread_mutexattr_init(&attrs);
+    ASSERT(result == 0);
+    result = pthread_mutexattr_settype(&attrs, PTHREAD_MUTEX_RECURSIVE);
+    ASSERT(result == 0);
+    result = pthread_mutex_init(&mutex_, &attrs);
+    ASSERT(result == 0);
+  }
+
+  virtual ~LinuxMutex() { pthread_mutex_destroy(&mutex_); }
+
+  virtual int Lock() {
+    int result = pthread_mutex_lock(&mutex_);
+    return result;
+  }
+
+  virtual int Unlock() {
+    int result = pthread_mutex_unlock(&mutex_);
+    return result;
+  }
+
+ private:
+  pthread_mutex_t mutex_;   // Pthread mutex for POSIX platforms.
+};
+
+
+Mutex* OS::CreateMutex() {
+  return new LinuxMutex();
+}
+
+
+class LinuxSemaphore : public Semaphore {
+ public:
+  explicit LinuxSemaphore(int count) {  sem_init(&sem_, 0, count); }
+  virtual ~LinuxSemaphore() { sem_destroy(&sem_); }
+
+  virtual void Wait();
+  virtual bool Wait(int timeout);
+  virtual void Signal() { sem_post(&sem_); }
+ private:
+  sem_t sem_;
+};
+
+
+void LinuxSemaphore::Wait() {
+  while (true) {
+    int result = sem_wait(&sem_);
+    if (result == 0) return;  // Successfully got semaphore.
+    CHECK(result == -1 && errno == EINTR);  // Signal caused spurious wakeup.
+  }
+}
+
+bool LinuxSemaphore::Wait(int timeout) {
+  //nacl is missing sem_timedwait
+  UNIMPLEMENTED();
+  return false;
+}
+
+Semaphore* OS::CreateSemaphore(int count) {
+  return new LinuxSemaphore(count);
+}
+Socket* OS::CreateSocket() {
+  //nacl is missing socket apis
+  UNIMPLEMENTED();
+  return 0;
+}
+
+bool Socket::Setup() {
+  return true;
+}
+
+int Socket::LastError() {
+  return errno;
+}
+
+int OS::ActivationFrameAlignment() {
+  return 32;
+}
+
+uint16_t Socket::HToN(uint16_t value) {
+  UNIMPLEMENTED();
+  return 0;
+}
+
+
+uint16_t Socket::NToH(uint16_t value) {
+  UNIMPLEMENTED();
+  return 0;
+}
+
+
+uint32_t Socket::HToN(uint32_t value) {
+  UNIMPLEMENTED();
+  return 0;
+}
+
+
+uint32_t Socket::NToH(uint32_t value) {
+  UNIMPLEMENTED();
+  return 0;
+}
+
+void OS::ReleaseStore(volatile AtomicWord* ptr, AtomicWord value) {
+  __asm__ __volatile__("" : : : "memory");
+  // An x86 store acts as a release barrier.
+  *ptr = value;
+}
+
+
+
+#ifdef ENABLE_LOGGING_AND_PROFILING
+
+void Sampler::Start() {
+  UNIMPLEMENTED();
+}
+void Sampler::Stop() {
+  UNIMPLEMENTED();
+}
+
+Sampler::Sampler(int interval, bool profiling)
+    : interval_(interval), profiling_(profiling), active_(false) {
+}
+
+Sampler::~Sampler() {
+}
+
+
+#endif  // ENABLE_LOGGING_AND_PROFILING
+
+} }  // namespace v8::internal
+
Index: src/assembler.h
===================================================================
--- src/assembler.h	(revision 4925)
+++ src/assembler.h	(working copy)
@@ -198,7 +198,7 @@
   // this relocation applies to;
   // can only be called if IsCodeTarget(rmode_) || rmode_ == RUNTIME_ENTRY
   INLINE(Address target_address());
-  INLINE(void set_target_address(Address target));
+  INLINE(void set_target_address(Address target, intptr_t extraoffset = 0));
   INLINE(Object* target_object());
   INLINE(Handle<Object> target_object_handle(Assembler* origin));
   INLINE(Object** target_object_address());
Index: src/v8.cc
===================================================================
--- src/v8.cc	(revision 4925)
+++ src/v8.cc	(working copy)
@@ -35,6 +35,7 @@
 #include "heap-profiler.h"
 #include "oprofile-agent.h"
 #include "log.h"
+#include <stdlib.h>
 
 namespace v8 {
 namespace internal {
@@ -166,7 +167,11 @@
 
 static uint32_t random_seed() {
   if (FLAG_random_seed == 0) {
+#ifdef NACL
+    return rand();
+#else
     return random();
+#endif
   }
   return FLAG_random_seed;
 }
Index: src/x64/cpu-x64.cc
===================================================================
--- src/x64/cpu-x64.cc	(revision 4925)
+++ src/x64/cpu-x64.cc	(working copy)
@@ -73,6 +73,8 @@
   // instead
   // __asm { int 3 }
   __debugbreak();
+#elif defined(NACL)
+  asm("hlt");
 #else
   asm("int $3");
 #endif
Index: src/naclcode.cc
===================================================================
--- src/naclcode.cc	(revision 0)
+++ src/naclcode.cc	(revision 0)
@@ -0,0 +1,336 @@
+// Copyright 2006-2010 the V8 project authors. All rights reserved.
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+//       notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+//       copyright notice, this list of conditions and the following
+//       disclaimer in the documentation and/or other materials provided
+//       with the distribution.
+//     * Neither the name of Google Inc. nor the names of its
+//       contributors may be used to endorse or promote products derived
+//       from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#include "v8.h"
+#include "naclcode.h"
+#include "utils.h"
+#include "platform.h"
+#include <sys/mman.h>
+#include <map>
+#include <list>
+#include <vector>
+
+#if 0
+class MiniTimer {
+public:
+  MiniTimer(const char* name) : name_(name) {
+    total_ = -rdtsc();
+  }
+  ~MiniTimer() {
+    total_ += rdtsc();
+    printf("TIMER: %s %.1f%% of time (%.0f/%.0f) \n", name_, 100.0*v_/(double)total_, (double)v_, (double)total_);
+  }
+  static int64_t rdtsc() {
+    union {
+      uint64_t v;
+      struct { uint32_t lo, hi; } b;
+    } u;
+    asm volatile ("rdtsc" : "=a" (u.b.lo), "=d"(u.b.hi));
+    return u.v;
+  }
+
+  void start() { v_ -= rdtsc(); }
+  void stop() { v_ += rdtsc(); }
+
+  const char* name_;
+  int64_t v_;
+  int64_t total_;
+};
+#else
+class MiniTimer {
+public:
+  MiniTimer(const char*){}
+  void start() {}
+  void stop() {}
+};
+#endif
+
+static MiniTimer TSYSCALL("NaCl Syscall");
+static MiniTimer TPATCH("NaCl Patching");
+
+#ifdef NACLPOSIX
+#undef NACL
+#endif
+
+#ifdef NACL
+#include <sys/nacl_syscalls.h>
+
+#ifndef MAP_NORESERVE
+#define MAP_NORESERVE 0
+#endif
+
+// evil constants taken from dynamic_load_test.c
+#define DYNAMIC_CODE_SEGMENT_START 0x600000
+#define DYNAMIC_CODE_SEGMENT_END 0x2000000
+
+#endif //NACL
+
+//#define NACLSIM
+
+namespace v8 {
+namespace internal { 
+
+  /*
+#ifdef NACL
+inline void memmove32(uint8_t* dst, uint8_t* src) {
+  //use sse registers
+  asm ( "movdqu (%0),   %%xmm0\n"
+        "movdqu 0x10(%0), %%xmm1\n"
+        "movdqu %%xmm0, (%1)\n"
+        "movdqu %%xmm1, 0x10(%1)\n"
+       : : "r"(src), "r"(dst)
+       : "xmm0", "xmm1", "memory" );
+}
+inline void memmove16(uint8_t* dst, uint8_t* src) {
+  //use sse registers
+  asm ( "movdqu (%0),   %%xmm0\n"
+        "movdqu %%xmm0, (%1)\n"
+       : : "r"(src), "r"(dst)
+       : "xmm0", "memory" );
+}
+#endif
+inline void memmove4(uint8_t* dst, uint8_t* src) {
+  *reinterpret_cast<uint32_t*>(dst) = *reinterpret_cast<uint32_t*>(src);
+}*/
+  
+const size_t kMaxCodeObjs = 128*1024;
+NaClCode::Tag kNaclDebugTag  = reinterpret_cast<NaClCode::Tag>(0xbad4ac1);
+
+#ifdef NACL
+const size_t kCodeBufSize = DYNAMIC_CODE_SEGMENT_END - DYNAMIC_CODE_SEGMENT_START;
+#else
+const size_t kCodeBufSize = 128*1024*1024;
+#endif
+
+#ifdef NACLSIM
+const size_t kCodeAlignment = 4096;
+int kCodeHeapProt = PROT_NONE;
+#else
+static const size_t kCodeAlignment = 32;
+static const int kCodeHeapProt = PROT_EXEC|PROT_READ|PROT_WRITE;
+#endif
+
+#define NACLDELETE
+
+class NaClCodeHeap {
+  struct SearchEntry {
+    uint8_t* inst_;
+    NaClCode::Tag code_;
+    SearchEntry(uint8_t* i = 0, NaClCode::Tag c = 0) : inst_(i), code_(c) {}
+  };
+public:
+  NaClCodeHeap(){
+#ifdef NACL
+    codeheap_ = reinterpret_cast<uint8_t*>(DYNAMIC_CODE_SEGMENT_START);
+    end_      = reinterpret_cast<uint8_t*>(DYNAMIC_CODE_SEGMENT_END);
+    freeptr_  = static_cast<uint8_t*>(codeheap_);
+    n_ = 0;
+#else
+    //use a big code buffer to mimic what we have to do in nacl
+    codeheap_ = mmap(0,
+                     kCodeBufSize,
+                     kCodeHeapProt,
+                     MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,
+                     -1,
+                     0);
+    freeptr_ = static_cast<uint8_t*>(codeheap_);
+    end_ = freeptr_ + kCodeBufSize;
+    n_ = 0;
+#endif//NACL
+  }
+
+  uint8_t* alloc(size_t bytes, NaClCode::Tag code) {
+#ifdef NACLDELETE
+    SearchEntryMap::iterator rb = freemap_.find(bytes);
+    if(rb != freemap_.end() && !rb->second.empty()) {
+      //reuse a recently deleted spot
+      SearchEntry* i = rb->second.back();
+      rb->second.pop_back();
+      i->code_ = code;
+      return i->inst_;
+    }
+#endif
+    //linear allocate a block of memory 
+    uint8_t* rv = freeptr_;
+    freeptr_+=bytes;
+    ASSERT(freeptr_<=end_);
+
+    //install search entry
+    ASSERT((unsigned int)n_<kMaxCodeObjs);
+    db_[n_++] = SearchEntry(rv, code);
+
+    return rv;
+  }
+
+
+  void dealloc(uint8_t* ptr, size_t bytes) {
+#ifdef NACLDELETE
+    /*
+     * We use an extremely simple allocation scheme for code reuse...
+     */
+    SearchEntry* entry = search(ptr, 0, n_-1);
+    ASSERT(entry->inst_ == ptr);
+    entry->code_ = NULL;
+#ifdef NACL
+    int rv = nacl_dyncode_delete(ptr, bytes);
+    CHECK(rv==0);
+#endif
+    freemap_[bytes].push_back(entry);
+#endif
+  }
+
+  //binary search the code heap
+  NaClCode::Tag search(uint8_t* p) {
+    if(!contains(p)){
+      return NULL;
+    }
+    return search(p, 0, n_-1)->code_;
+  }
+  
+  bool contains(uint8_t* p) {
+    return !(p<codeheap_ || p>=freeptr_ || n_==0);
+  }
+
+
+private:
+  //binary search the code heap
+  SearchEntry* search(uint8_t* p, int begin, int end) {
+    if(begin==end){
+      return db_+begin;
+    }
+    int mid=(begin+end+1)/2;
+    if(db_[mid].inst_ <= p){
+      return search(p, mid, end);
+    }else{
+      return search(p, begin, mid-1);
+    }
+  }
+
+private:
+  void* codeheap_;
+  uint8_t* freeptr_;
+  const uint8_t* end_;
+  int n_;
+  SearchEntry db_[kMaxCodeObjs];
+
+#ifdef NACLDELETE
+  typedef std::vector<SearchEntry*> SearchEntryList;
+  typedef std::map<size_t, SearchEntryList> SearchEntryMap;
+  SearchEntryMap freemap_;
+#endif
+
+} theNaClHeap;
+
+
+uint8_t* NaClCode::Allocate(size_t bytes, NaClCode::Tag backpointer) {
+#ifdef NACL_USE_BACKPOINTER
+  const int extra = kCodeAlignment;
+#else
+  const int extra = 0;
+#endif
+
+  //extra block for backpointer
+  uint8_t* rv = theNaClHeap.alloc(RoundUp(bytes, kCodeAlignment)+extra,
+                                  backpointer);
+
+#ifdef NACL_USE_BACKPOINTER
+  //install backpointer
+  rv+=kCodeAlignment;
+  reinterpret_cast<NaClCode::Tag*>(rv)[-1] = backpointer;
+#ifdef DEBUG
+  reinterpret_cast<NaClCode::Tag*>(rv)[-2] = kNaclDebugTag;
+#endif
+#endif
+
+  return rv;
+}
+
+void NaClCode::Deallocate(uint8_t* ptr, size_t bytes) {
+  theNaClHeap.dealloc(ptr, RoundUp(bytes, kCodeAlignment));
+}
+  
+void NaClCode::Install(uint8_t* dst, uint8_t* src, size_t bytes){
+  ASSERT(IsProtectedCode(dst) && !IsProtectedCode(src));
+
+#if defined(NACL)
+  TSYSCALL.start();
+  int rc = nacl_dyncode_create(dst, src, bytes);
+  TSYSCALL.stop();
+  if(rc != 0) {
+    fprintf(stderr, "V8/NaCl - Dynamic Creation Failure:\n\tsrc: %p\n\tdst: %p\n\tsize: %d\n\tdebugoffset: +0x%x\n\tcode object: %8p\n",
+        src, dst, bytes, src-dst, (void*)Search(dst));
+    OS::DebugBreak();
+  }
+#elif defined(NACLSIM)
+  CHECK(mprotect(dst, RoundUp(bytes, kCodeAlignment), PROT_READ|PROT_WRITE)==0);
+  memmove(dst, src, bytes);
+  CHECK(mprotect(dst, RoundUp(bytes, kCodeAlignment), PROT_READ|PROT_EXEC)==0);
+#else
+  memmove(dst, src, bytes);
+#endif
+}
+  
+NaClCode::Tag NaClCode::GetBackpointer(uint8_t* inst) {
+#ifdef NACL_USE_BACKPOINTER
+  ASSERT(reinterpret_cast<NaClCode::Tag*>(inst)[-2] == kNaclDebugTag);
+  return reinterpret_cast<NaClCode::Tag*>(inst)[-1];
+#else
+  return Search(inst);
+#endif
+}
+  
+NaClCode::Tag NaClCode::Search(uint8_t* inst) {
+  return theNaClHeap.search(inst);
+}
+  
+bool NaClCode::IsProtectedCode(uint8_t* dst) {
+  return theNaClHeap.contains(dst);
+}
+  
+void NaClCode::Modify(uint8_t* dst, uint8_t* src, size_t bytes) {
+#ifdef NACL
+  ASSERT(NaClCode::IsProtectedCode(dst));
+  TPATCH.start();
+  int rc = nacl_dyncode_modify(dst, src, bytes);
+  TPATCH.stop();
+  if(rc != 0) {
+    fprintf(stderr, "V8/NaCl - Dynamic Replacement Failure:\n\tsrc: %p\n\tdst: %p\n\tsize: %d\n\tdebugoffset: +0x%x\n\tcode object: %8p\n",
+        src, dst, bytes, src-dst, (void*)Search(dst));
+    OS::DebugBreak();
+  }
+#else
+  memcpy(dst, src, bytes);
+#endif
+}
+
+}} //v8::internal
+
+
+
+
+
+
Index: src/objects-inl.h
===================================================================
--- src/objects-inl.h	(revision 4925)
+++ src/objects-inl.h	(working copy)
@@ -39,6 +39,7 @@
 #include "contexts.h"
 #include "conversions-inl.h"
 #include "property.h"
+#include "naclcode.h"
 
 namespace v8 {
 namespace internal {
@@ -2311,15 +2312,18 @@
   return static_cast<Flags>(bits);
 }
 
+Code* Code::GetCodeFromTargetAddress(Address address) {
+  //NACL_CHANGE:
+  return NaClCode::GetBackpointer(address);
 
-Code* Code::GetCodeFromTargetAddress(Address address) {
-  HeapObject* code = HeapObject::FromAddress(address - Code::kHeaderSize);
+  //HeapObject* code = HeapObject::FromAddress(address - Code::kHeaderSize);
+
   // GetCodeFromTargetAddress might be called when marking objects during mark
   // sweep. reinterpret_cast is therefore used instead of the more appropriate
   // Code::cast. Code::cast does not work when the object's map is
   // marked.
-  Code* result = reinterpret_cast<Code*>(code);
-  return result;
+  //Code* result = reinterpret_cast<Code*>(code);
+  //return result;
 }
 
 
@@ -2745,19 +2749,35 @@
 INT_ACCESSORS(Code, relocation_size, kRelocationSizeOffset)
 INT_ACCESSORS(Code, sinfo_size, kSInfoSizeOffset)
 
+//NACL_CHANGE: add external_instructions field:
+byte* Code::external_instructions() {
+  intptr_t ptr = READ_INTPTR_FIELD(this, kExternalInstructionsOffset);
+  return reinterpret_cast<byte*>(ptr);
+}
 
+//NACL_CHANGE: add external_instructions field:
+void Code::set_external_instructions(byte* value) { 
+  intptr_t ptr = reinterpret_cast<intptr_t>(value);
+  WRITE_INTPTR_FIELD(this, kExternalInstructionsOffset, ptr);
+}
+
 byte* Code::instruction_start()  {
-  return FIELD_ADDR(this, kHeaderSize);
+//NACL_CHANGE: split instructions to separate object
+  return external_instructions();
+//  return FIELD_ADDR(this, kHeaderSize);
 }
 
-
 int Code::body_size() {
-  return RoundUp(instruction_size() + relocation_size(), kObjectAlignment);
+//NACL_CHANGE: dont include instructions in body size
+  //return RoundUp(instruction_size() + relocation_size(), kObjectAlignment);
+  return RoundUp(relocation_size(), kObjectAlignment);
 }
 
 
 byte* Code::relocation_start() {
-  return FIELD_ADDR(this, kHeaderSize + instruction_size());
+  //NACL_CHANGE: no longer place this after instructions
+  //return FIELD_ADDR(this, kHeaderSize + instruction_size());
+  return FIELD_ADDR(this, kHeaderSize);
 }
 
 
Index: src/assembler.cc
===================================================================
--- src/assembler.cc	(revision 4925)
+++ src/assembler.cc	(working copy)
@@ -477,7 +477,9 @@
            *target_reference_address());
   } else if (IsCodeTarget(rmode_)) {
     Code* code = Code::GetCodeFromTargetAddress(target_address());
-    PrintF(" (%s)  (%p)", Code::Kind2String(code->kind()), target_address());
+    if(code!=0) {
+      PrintF(" (%s)  (%p)", Code::Kind2String(code->kind()), target_address());
+    }
   } else if (IsPosition(rmode_)) {
     PrintF("  (%d)", data());
   }
@@ -506,9 +508,12 @@
       ASSERT(addr != NULL);
       // Check that we can find the right code object.
       Code* code = Code::GetCodeFromTargetAddress(addr);
-      Object* found = Heap::FindCodeObject(addr);
-      ASSERT(found->IsCode());
-      ASSERT(code->address() == HeapObject::cast(found)->address());
+      //NACL_CHANGE: heap search is broken for code (which is not in heap anymore)
+      //             so dont test it
+      //Object* found = Heap::FindCodeObject(addr);
+      //ASSERT(found->IsCode());
+      //ASSERT(code->address() == HeapObject::cast(found)->address());
+      USE(code);
       break;
     }
     case RUNTIME_ENTRY:
Index: src/mark-compact.cc
===================================================================
--- src/mark-compact.cc	(revision 4925)
+++ src/mark-compact.cc	(working copy)
@@ -2312,13 +2312,20 @@
 
 
 void MarkCompactCollector::ReportDeleteIfNeeded(HeapObject* obj) {
-#ifdef ENABLE_LOGGING_AND_PROFILING
+#if defined(ENABLE_LOGGING_AND_PROFILING) || defined(NACL)
   if (obj->IsCode()) {
+#ifdef NACL
+    Code::cast(obj)->NaClOnDelete();
+#endif
+#if !defined(ENABLE_LOGGING_AND_PROFILING)
+  }
+#else
     PROFILE(CodeDeleteEvent(obj->address()));
   } else if (obj->IsJSFunction()) {
     PROFILE(FunctionDeleteEvent(obj->address()));
   }
 #endif
+#endif
 }
 
 } }  // namespace v8::internal
Index: src/platform-posix.cc
===================================================================
--- src/platform-posix.cc	(revision 4925)
+++ src/platform-posix.cc	(working copy)
@@ -33,14 +33,19 @@
 #include <errno.h>
 #include <time.h>
 
+#if !defined(NACL) || defined(NACLPOSIX)
 #include <sys/socket.h>
+#endif // !defined(NACL)
+
 #include <sys/resource.h>
 #include <sys/time.h>
 #include <sys/types.h>
 
+#if !defined(NACL) || defined(NACLPOSIX)
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <netdb.h>
+#endif // !defined(NACL)
 
 #if defined(ANDROID)
 #define LOG_TAG "v8"
@@ -51,6 +56,10 @@
 
 #include "platform.h"
 
+#if defined(NACLPOSIX)
+#undef NACL //disable NACL exception in this file
+#endif
+
 namespace v8 {
 namespace internal {
 
@@ -72,6 +81,8 @@
 // POSIX date/time support.
 //
 
+#ifndef NACL
+
 int OS::GetUserTime(uint32_t* secs,  uint32_t* usecs) {
   struct rusage usage;
 
@@ -81,7 +92,9 @@
   return 0;
 }
 
+#endif // !defined(NACL)
 
+
 double OS::TimeCurrentMillis() {
   struct timeval tv;
   if (gettimeofday(&tv, NULL) < 0) return 0.0;
@@ -154,6 +167,8 @@
 }
 
 
+#ifndef NACL
+
 int OS::SNPrintF(Vector<char> str, const char* format, ...) {
   va_list args;
   va_start(args, format);
@@ -163,6 +178,7 @@
 }
 
 
+
 int OS::VSNPrintF(Vector<char> str,
                   const char* format,
                   va_list args) {
@@ -175,7 +191,9 @@
   }
 }
 
+#endif // !defined(NACL)
 
+
 // ----------------------------------------------------------------------------
 // POSIX string support.
 //
@@ -194,6 +212,8 @@
 // POSIX socket support.
 //
 
+#ifndef NACL
+
 class POSIXSocket : public Socket {
  public:
   explicit POSIXSocket() {
@@ -358,5 +378,6 @@
   return new POSIXSocket();
 }
 
+#endif // !defined(NACL)
 
 } }  // namespace v8::internal
Index: src/dtoa-config.c
===================================================================
--- src/dtoa-config.c	(revision 4925)
+++ src/dtoa-config.c	(working copy)
@@ -39,7 +39,7 @@
 
 #if !(defined(__APPLE__) && defined(__MACH__)) && \
     !defined(WIN32) && !defined(__FreeBSD__) && !defined(__OpenBSD__) && \
-    !defined(__sun)
+    !defined(__sun) && !defined(NACL)
 #include <endian.h>
 #endif
 #include <math.h>
Index: SConstruct
===================================================================
--- SConstruct	(revision 4925)
+++ SConstruct	(working copy)
@@ -54,6 +54,11 @@
 else:
   ARM_LINK_FLAGS = []
 
+NACLSDK=os.environ.get('NACLSDK')
+if NACLSDK is None:
+  NACLSDK=""
+
+
 # TODO: Sort these issues out properly but as a temporary solution for gcc 4.4
 # on linux we need these compiler flags to avoid crashes in the v8 test suite
 # and avoid dtoa.c strict aliasing issues
@@ -186,6 +191,16 @@
       'LIBPATH' : ['/usr/local/lib'],
       'CCFLAGS':      ['-ansi'],
     },
+    'os:nacl': {
+      'CCFLAGS'   : ['-ansi', '-fno-tree-vrp', '-fno-strict-aliasing', '-march=native'] + GCC_EXTRA_CCFLAGS,
+      'CPPDEFINES': ['NACL'],
+      'CPP'       : os.path.join(NACLSDK,'nacl-cpp'),
+      'CXX'       : os.path.join(NACLSDK,'nacl-g++'),
+      'CC'        : os.path.join(NACLSDK,'nacl-gcc'),
+      'AR'        : os.path.join(NACLSDK,'nacl-ar'),
+      'LD'        : os.path.join(NACLSDK,'nacl-ld'),
+      'RANLIB'    : os.path.join(NACLSDK,'nacl-ranlib'),
+    },
     'os:win32': {
       'CCFLAGS':      ['-DWIN32'],
       'CXXFLAGS':     ['-DWIN32'],
@@ -300,7 +315,6 @@
   'gcc': {
     'all': {
       'WARNINGFLAGS': ['-Wall',
-                       '-Werror',
                        '-W',
                        '-Wno-unused-parameter',
                        '-Wnon-virtual-dtor']
@@ -316,6 +330,9 @@
         }
       }
     },
+    'os:nacl': {
+      'WARNINGFLAGS': ['-pedantic']
+    },
     'os:macos': {
       'WARNINGFLAGS': ['-pedantic']
     },
@@ -381,7 +398,7 @@
 DTOA_EXTRA_FLAGS = {
   'gcc': {
     'all': {
-      'WARNINGFLAGS': ['-Werror', '-Wno-uninitialized'],
+      'WARNINGFLAGS': ['-Wno-uninitialized'],
       'CCFLAGS': GCC_DTOA_EXTRA_CCFLAGS
     }
   },
@@ -403,7 +420,11 @@
     },
     'os:linux': {
       'LIBS':         ['pthread'],
+      'LINKFLAGS': [ "-Wl,--section-start,.rodata=0x10000000"],
     },
+    'os:nacl': {
+      'LIBS':         ['pthread'],
+    },
     'os:macos': {
       'LIBS':         ['pthread'],
     },
@@ -468,6 +489,16 @@
     'os:linux': {
       'LIBS':         ['pthread'],
     },
+    'os:nacl': {
+      'LIBS':     ['pthread'],
+      'CPP'       : os.path.join(NACLSDK,'nacl-cpp'),
+      'CXX'       : os.path.join(NACLSDK,'nacl-g++'),
+      'CC'        : os.path.join(NACLSDK,'nacl-gcc'),
+      'AR'        : os.path.join(NACLSDK,'nacl-ar'),
+      'LD'        : os.path.join(NACLSDK,'nacl-ld'),
+      'RANLIB'    : os.path.join(NACLSDK,'nacl-ranlib'),
+      'LINKFLAGS' : ["-Wl,--section-start,.rodata=0x10000000"],
+    },
     'os:macos': {
       'LIBS':         ['pthread'],
     },
@@ -671,7 +702,7 @@
     'help': 'the toolchain to use (' + TOOLCHAIN_GUESS + ')'
   },
   'os': {
-    'values': ['freebsd', 'linux', 'macos', 'win32', 'android', 'openbsd', 'solaris'],
+    'values': ['freebsd', 'linux', 'macos', 'win32', 'android', 'openbsd', 'solaris', 'nacl'],
     'default': OS_GUESS,
     'help': 'the os to build for (' + OS_GUESS + ')'
   },
