Index: src/trusted/validator_x86/ncvalidate_iter_internal.h
===================================================================
--- src/trusted/validator_x86/ncvalidate_iter_internal.h	(revision 3669)
+++ src/trusted/validator_x86/ncvalidate_iter_internal.h	(working copy)
@@ -54,6 +54,14 @@
    * bits in an address that violate alignment.
    */
   NaClPcAddress alignment_mask;
+  /* Start of NaCl's text segment; this is used to validate external jump
+   * targets */
+  NaClPcAddress text_start;
+  /* Size of the NaCl's text segment, used to validate external jump targets */
+  NaClMemorySize text_size;
+  /* Disable validation of external jump targets */
+  Bool allow_external_targets;
+
   /* Holds the value for the base register, or RegUnknown if undefined. */
   NaClOpKind base_register;
   /* Holds if the validation is still valid. */
Index: src/trusted/validator_x86/ncdecode.c
===================================================================
--- src/trusted/validator_x86/ncdecode.c	(revision 3669)
+++ src/trusted/validator_x86/ncdecode.c	(working copy)
@@ -485,6 +485,37 @@
   return newpc;
 }
 
+NaClPcAddress NCGetExternalTarget(uint8_t *sys_source, NaClPcAddress source, struct NCValidatorState *vstate) {
+  struct NCDecoderState decodebuffer[kDecodeBufferSize];
+  struct NCDecoderState *mstate;
+  uint8_t *opcode;
+
+  InitDecodeBuffer(sys_source, source, vstate, decodebuffer, &mstate);
+  ConsumeNextInstruction(mstate);
+
+  opcode = mstate->inst.maddr + mstate->inst.prefixbytes;
+  
+  if (mstate->opinfo->insttype == NACLi_JMP8) {
+    if ((*opcode & 0xf0) == 0x70 || *opcode == 0xeb ||
+         *opcode == 0xe0 || *opcode == 0xe1 || *opcode == 0xe2 || *opcode == 0xe3) {
+      int8_t offset = *(int8_t *)(mstate->inst.maddr + mstate->inst.prefixbytes + 1);
+      return (NaClPcAddress) (mstate->inst.vaddr + mstate->inst.length + offset);
+    }
+  } else if (mstate->opinfo->insttype == NACLi_JMPZ) {
+    int32_t offset;
+    if (*opcode == 0xe8 || *opcode == 0xe9) {
+      offset = *(int32_t *)&opcode[1];
+      return (NaClPcAddress) (mstate->inst.vaddr + mstate->inst.length + offset);
+    }
+    if ((*opcode == 0x0f) && ((opcode[1] & 0xf0) == 0x80)) {
+      offset = *(int32_t *)&opcode[2];
+      return (NaClPcAddress) (mstate->inst.vaddr + mstate->inst.length + offset);
+    }
+  }
+
+  return 0;
+}
+
 /* The actual decoder */
 void NCDecodeSegment(uint8_t *mbase, NaClPcAddress vbase,
                      NaClMemorySize size,
Index: src/trusted/validator_x86/ncdecode.h
===================================================================
--- src/trusted/validator_x86/ncdecode.h	(revision 3669)
+++ src/trusted/validator_x86/ncdecode.h	(working copy)
@@ -338,4 +338,6 @@
 extern struct NCDecoderState *PreviousInst(const struct NCDecoderState *mstate,
                                            int nindex);
 
+NaClPcAddress NCGetExternalTarget(uint8_t *sys_source, NaClPcAddress source, struct NCValidatorState *vstate);
+
 #endif /* NATIVE_CLIENT_SRC_TRUSTED_VALIDATOR_X86_NCDECODE_H_ */
Index: src/trusted/validator_x86/ncvalidate.c
===================================================================
--- src/trusted/validator_x86/ncvalidate.c	(revision 3669)
+++ src/trusted/validator_x86/ncvalidate.c	(working copy)
@@ -38,6 +38,8 @@
 /* allows DCE but compiler can still do format string checks */
 #endif  /* VERBOSE */
 
+static void NCValidateExternalTarget(NaClPcAddress source, struct NCValidatorState *vstate); /* forward declaration */
+
 static const uint8_t kNaClFullStop = 0xf4;   /* x86 HALT opcode */
 
 /* Define how many diagnostic error messages are printed by the validator.
@@ -45,7 +47,7 @@
  * A value >0 allows up to that many diagnostic error messages.
  * A negative value prints all diagnostic error messages.
  */
-static int kMaxDiagnostics = 0;
+static int kMaxDiagnostics = -1;
 
 int NCValidatorGetMaxDiagnostics() {
   return kMaxDiagnostics;
@@ -59,10 +61,10 @@
                                struct NCValidatorState *vstate) {
 
   if (vstate->num_diagnostics != 0) {
-    printf("VALIDATOR: %"NACL_PRIxNaClPcAddress": %s\n", addr, msg);
+    fprintf(stderr, "VALIDATOR: %"NACL_PRIxNaClPcAddress": %s\n", addr, msg);
     --(vstate->num_diagnostics);
     if (vstate->num_diagnostics == 0) {
-      printf("VALIDATOR: Error limit reached, turning off diagnostics!\n");
+      fprintf(stderr, "VALIDATOR: Error limit reached, turning off diagnostics!\n");
     }
   }
 }
@@ -286,19 +288,12 @@
   BadPrefixMask[NACLi_CMPXCHG8B] = ~kPrefixLOCK;
 }
 
-/*
- * NCValidateInit: Initialize NaCl validator internal state
- * Parameters:
- *    vbase: base virtual address for code segment
- *    vlimit: size in bytes of code segment
- *    alignment: 16 or 32, specifying alignment
- * Returns:
- *    an initialized struct NCValidatorState * if everything is okay,
- *    else NULL
- */
-struct NCValidatorState *NCValidateInit(const uint32_t vbase,
-                                        const uint32_t vlimit,
-                                        const uint8_t alignment) {
+static struct NCValidatorState *NCValidateInitInternal(const uint32_t vbase,
+                                                   const uint32_t vlimit,
+                                                   const uint8_t alignment,
+                                                   const uintptr_t region_start,
+                                                   const size_t region_size,
+                                                   const uintptr_t text_base) {
   struct NCValidatorState *vstate;
 
   dprint(("NCValidateInit(%08x, %08x, %08x)\n", vbase, vlimit, alignment));
@@ -317,8 +312,15 @@
     vstate->alignmask = alignment-1;
     vstate->vttable = (uint8_t *)calloc(IATOffset(vlimit - vbase) + 1, 1);
     vstate->kttable = (uint8_t *)calloc(IATOffset(vlimit - vbase) + 1, 1);
+    vstate->ettable = NULL;
     vstate->do_stub_out = 0;
+    vstate->region_start = region_start;
+    vstate->region_size = region_size;
+    vstate->text_base = text_base;
+    vstate->enable_external_targets = 0;
+    vstate->allow_external_targets = 0;
     if (vstate->vttable == NULL || vstate->kttable == NULL) break;
+    if (vstate->text_base > vstate->region_start) break;
     dprint(("  allocated tables\n"));
     Stats_Init(vstate);
     NCDecodeRegisterCallbacks(ValidateInst, Stats_NewSegment,
@@ -329,6 +331,68 @@
   return NULL;
 }
 
+/*
+ * NCValidateInit: Initialize NaCl validator internal state
+ * Parameters:
+ *    vbase: base virtual address for code segment
+ *    vlimit: size in bytes of code segment
+ *    alignment: 16 or 32, specifying alignment
+ * Returns:
+ *    an initialized struct NCValidatorState * if everything is okay,
+ *    else NULL
+ */
+struct NCValidatorState *NCValidateInit(const uint32_t vbase,
+                                        const uint32_t vlimit,
+                                        const uint8_t alignment) {
+  return NCValidateInitInternal(vbase, vlimit, alignment, 0, 0, 0);
+}
+
+static void NCValidatorStateEnableExternalTargets(
+                                              struct NCValidatorState *state) {
+  state->enable_external_targets = 1;
+}
+
+static bool NCValidatorStateAllocateExternalTargetTable(
+                                              struct NCValidatorState *state) {
+  state->ettable = (uint8_t *)calloc(IATOffset(state->iadrlimit - state->iadrbase) + 1, 1);
+  if (state->ettable)
+    return 1;
+  return 0;
+}
+
+void NCValidatorStateAllowExternalTargets(struct NCValidatorState *state) {
+  state->allow_external_targets = 1;
+}
+
+bool NCValidatorIsAddressInRegion(struct NCValidatorState *state, uintptr_t addr) {
+  if (addr >= (state->region_start - state->text_base) &&
+      addr < (state->region_start - state->text_base + state->region_size))
+    return 1;
+  return 0;
+}
+
+struct NCValidatorState *NCValidateInitWithExternalTargets(
+                                        const uint32_t vbase,
+                                        const uint32_t vlimit,
+                                        const uint8_t alignment,
+                                        const uintptr_t region_start,
+                                        const size_t region_size,
+                                        const uintptr_t text_base) {
+  struct NCValidatorState *state;
+  state = NCValidateInitInternal(vbase,
+                                 vlimit,
+                                 alignment,
+                                 region_start,
+                                 region_size,
+                                 text_base);
+  if (state == NULL)
+    return state;
+
+  NCValidatorStateEnableExternalTargets(state);
+  return state;
+}
+
+
 void NCValidateSetStubOutMode(struct NCValidatorState *vstate,
                               int do_stub_out) {
   vstate->do_stub_out = do_stub_out;
@@ -355,6 +419,7 @@
 static void RememberTP(const NaClPcAddress src, NaClPcAddress target,
                        struct NCValidatorState *vstate) {
   const NaClMemorySize ioffset =  target - vstate->iadrbase;
+  const NaClMemorySize src_ioffset = src - vstate->iadrbase;
 
   if (vstate->iadrbase <= target && target < vstate->iadrlimit) {
     /* Remember address for checking later. */
@@ -363,6 +428,17 @@
   else if ((target & vstate->alignmask) == 0) {
     /* Allow bundle-aligned jumps. */
   }
+  else if (vstate->allow_external_targets) {
+    /* external targets are allowed */
+  }
+  else if (vstate->enable_external_targets && NCValidatorIsAddressInRegion(vstate, target)) {
+    if (vstate->ettable == NULL) 
+      if (!NCValidatorStateAllocateExternalTargetTable(vstate)) {
+        ValidatePrintError(src, "Allocation of ettable failed", vstate);
+        return;
+      }
+    SetAdrTable(src_ioffset, vstate->ettable);
+  } 
   else {
     ValidatePrintError(src, "JUMP TARGET out of range", vstate);
     Stats_BadTarget(vstate);
@@ -416,6 +492,17 @@
       Stats_BadAlignment(vstate);
     }
   }
+  if (vstate->enable_external_targets && 
+      !vstate->allow_external_targets &&
+      vstate->ettable) {
+    for (offset = 0;
+         offset < vstate->iadrlimit - vstate->iadrbase;
+         offset += 1) {
+      if (GetAdrTable(offset, vstate->ettable)) {
+        NCValidateExternalTarget(offset + vstate->iadrbase, vstate);
+      }
+    }
+  }
   fflush(stdout);
 
   /* Now that all the work is done, generate return code. */
@@ -427,6 +514,7 @@
   if (*vstate == NULL) return;
   free((*vstate)->vttable);
   free((*vstate)->kttable);
+  if ((*vstate)->ettable) free((*vstate)->ettable);
   free(*vstate);
   *vstate = NULL;
 }
@@ -807,6 +895,50 @@
   NCDecodeSegment(mbase, vbase, sz, vstate);
 }
 
+static void NCValidateExternalTarget(NaClPcAddress source, struct NCValidatorState *vstate) {
+  struct NCValidatorState *local_state;
+  NaClMemorySize offset;
+  NaClPcAddress bundle_start;
+  NaClPcAddress bundle_vstart;
+  size_t bundle_size;
+  NaClPcAddress target = NCGetExternalTarget((uint8_t *)(vstate->text_base + source), source, vstate);
+  
+  if (!target) {
+    ValidatePrintError(source, "Faild to get external target", vstate);
+    Stats_BadTarget(vstate);
+    return;
+  }
+
+  if ((vstate->text_base + target) < vstate->region_start || 
+      (vstate->text_base + target - vstate->region_start) > vstate->region_size) {
+    ValidatePrintError(source, "Bad external target", vstate);
+    Stats_BadTarget(vstate);
+    return;
+  }
+
+
+  bundle_start = (vstate->text_base + target) & ~vstate->alignmask;
+  bundle_vstart = target & ~vstate->alignmask;
+  bundle_size = vstate->alignment;
+  local_state = NCValidateInit(bundle_vstart,
+                               bundle_vstart + bundle_size,
+                               vstate->alignment);
+  if (local_state == NULL) {
+    ValidatePrintError(source, "Faild to allocate internal state", vstate);
+    return;
+  }
+  NCValidatorStateAllowExternalTargets(local_state);
+
+  NCValidateSegment((uint8_t*)bundle_start, bundle_vstart, bundle_size, local_state);
+  offset =  target - local_state->iadrbase; 
+  if (!GetAdrTable(offset, local_state->vttable)) {
+    ValidatePrintError(source, "Bad jump target", vstate);
+    Stats_BadTarget(vstate);
+  }
+
+  NCValidateFreeState(&local_state);
+}
+
 /*
  * (Same as NCValidateSegment, but operates on a pair of instructions.)
  * Validates that instructions at mbase_new may replace mbase_old.
Index: src/trusted/validator_x86/ncvalidate.h
===================================================================
--- src/trusted/validator_x86/ncvalidate.h	(revision 3669)
+++ src/trusted/validator_x86/ncvalidate.h	(working copy)
@@ -42,6 +42,16 @@
                                         const NaClPcAddress vlimit,
                                         const uint8_t alignment);
 
+struct NCValidatorState *NCValidateInitWithExternalTargets(
+                                        const NaClPcAddress vbase,
+                                        const NaClPcAddress vlimit,
+                                        const uint8_t alignment,
+                                        const uintptr_t region_start,
+                                        const size_t region_size,
+                                        const uintptr_t text_base);
+
+void NCValidatorStateAllowExternalTargets(struct NCValidatorState *state);
+
 /*
  * Allows "stub out mode" to be enabled, in which some unsafe
  * instructions will be rendered safe by replacing them with HLT
Index: src/trusted/validator_x86/nccopycode.c
===================================================================
--- src/trusted/validator_x86/nccopycode.c	(revision 3669)
+++ src/trusted/validator_x86/nccopycode.c	(working copy)
@@ -23,9 +23,17 @@
 #include <errno.h>
 #include <string.h>
 #include <assert.h>
+#include "native_client/src/shared/platform/nacl_check.h"
+#if NACL_TARGET_SUBARCH == 32
 #include "native_client/src/trusted/validator_x86/ncdecode.h"
 #include "native_client/src/trusted/validator_x86/ncvalidate.h"
-#include "native_client/src/shared/platform/nacl_check.h"
+#elif NACL_TARGET_SUBARCH == 64
+#include "native_client/src/trusted/validator_x86/nc_inst_iter.h"
+#include "native_client/src/trusted/validator_x86/nc_segment.h"
+#include "native_client/src/trusted/validator_x86/nc_inst_state_internal.h"
+#else
+#error "Unknown Platform"
+#endif
 
 /* x86 HALT opcode */
 static const uint8_t kNaClFullStop = 0xf4;
@@ -137,9 +145,9 @@
   rv = VirtualProtect(g_squashybuffer, size, prot, &oldprot);
   CHECK(rv);
 #else
-  static const int prot_a = PROT_READ|PROT_WRITE|PROT_EXEC;
-  static const int prot_b = PROT_NONE;
-  static int prot = PROT_NONE;
+  static const int prot_a = PROT_READ|PROT_WRITE;
+  static const int prot_b = PROT_READ;
+  static int prot = PROT_READ|PROT_WRITE;
   static int size = 0;
   int rv;
   if (NULL == g_squashybuffer) {
@@ -158,13 +166,11 @@
  * Copy a single instruction, avoiding the possibility of other threads
  * executing a partially changed instruction.
  */
-void CopyInstruction(const struct NCDecoderState *mstate_old,
-                     const struct NCDecoderState *mstate_new) {
-  uint8_t* dst = mstate_old->inst.maddr;
-  uint8_t* src = mstate_new->inst.maddr;
-  int sz = mstate_old->inst.length;
+void CopyInstructionInternal(uint8_t *dst,
+                             uint8_t *src,
+                             uint8_t sz) {
   intptr_t offset = 0;
-  CHECK(mstate_new->inst.length == mstate_old->inst.length);
+  uint8_t *firstbyte_p = dst;
 
   while (sz > 0 && dst[0] == src[0]) {
     /* scroll to first changed byte */
@@ -196,13 +202,13 @@
     onestore_memmove8(dst-offset, tmp);
   } else {
     /* the slow path, first flip first byte to halt*/
-    uint8_t firstbyte = mstate_old->inst.maddr[0];
-    mstate_old->inst.maddr[0] = kNaClFullStop;
+    uint8_t firstbyte = firstbyte_p[0];
+    firstbyte_p[0] = kNaClFullStop;
 
     SerializeAllProcessors();
 
     /* copy the rest of instruction */
-    if (dst == mstate_old->inst.maddr) {
+    if (dst == firstbyte_p) {
       /* but not the first byte! */
       firstbyte = *src;
       dst++, src++, sz--;
@@ -212,10 +218,25 @@
     SerializeAllProcessors();
 
     /* flip first byte back */
-    mstate_old->inst.maddr[0] = firstbyte;
+    firstbyte_p[0] = firstbyte;
   }
 }
 
+#if NACL_TARGET_SUBARCH == 32
+
+/*
+ * Copy a single instruction, avoiding the possibility of other threads
+ * executing a partially changed instruction.
+ */
+void CopyInstruction(const struct NCDecoderState *mstate_old,
+                     const struct NCDecoderState *mstate_new) {
+  CHECK(mstate_new->inst.length == mstate_old->inst.length);
+
+  CopyInstructionInternal(mstate_old->inst.maddr,
+                          mstate_new->inst.maddr,
+                          mstate_old->inst.length);
+}
+
 int NCCopyCode(uint8_t *dst, uint8_t *src, NaClPcAddress vbase,
                size_t sz, int bundle_size) {
   struct NCValidatorState *vstate;
@@ -226,3 +247,44 @@
   return 0;
 }
 
+#elif NACL_TARGET_SUBARCH == 64
+
+int NaClCopyCodeIter(uint8_t *dst, uint8_t *src,
+                     NaClPcAddress vbase, size_t size) {
+  NaClSegment segment_old, segment_new;
+  NaClInstIter *iter_old, *iter_new;
+  NaClInstState *istate_old, *istate_new;
+
+  NaClSegmentInitialize(dst, vbase, size, &segment_old);
+  NaClSegmentInitialize(src, vbase, size, &segment_new);
+
+  iter_old = NaClInstIterCreate(&segment_old);
+  iter_new = NaClInstIterCreate(&segment_new);
+  while (NaClInstIterHasNext(iter_old) &&
+         NaClInstIterHasNext(iter_new)) {
+    istate_old = NaClInstIterGetState(iter_old);
+    istate_new = NaClInstIterGetState(iter_new);
+    if (istate_old->length != istate_new->length ||
+        istate_new->vpc != istate_old->vpc) {
+      NaClLog(LOG_ERROR,
+              "Segment replacement: copied instructions misaligned\n");
+      return 1;
+    }
+    CopyInstructionInternal(istate_old->mpc,
+                            istate_new->mpc,
+                            istate_old->length);
+    NaClInstIterAdvance(iter_old);
+    NaClInstIterAdvance(iter_new);
+  }
+
+  CHECK(!NaClInstIterHasNext(iter_old) && !NaClInstIterHasNext(iter_new));
+
+  NaClInstIterDestroy(iter_old);
+  NaClInstIterDestroy(iter_new);
+  return 0;
+}
+
+#else
+#error "Unknown Platform"
+#endif
+
Index: src/trusted/validator_x86/nccopycode.h
===================================================================
--- src/trusted/validator_x86/nccopycode.h	(revision 3669)
+++ src/trusted/validator_x86/nccopycode.h	(working copy)
@@ -9,9 +9,17 @@
 
 #include "native_client/src/trusted/validator_x86/types_memory_model.h"
 
+#if NACL_TARGET_SUBARCH == 32
 /* copies code from src to dest in a thread safe way, returns 0 on success */
 int NCCopyCode(uint8_t *dst, uint8_t *src, NaClPcAddress vbase,
                 size_t sz, int bundle_size);
 
+#elif NACL_TARGET_SUBARCH == 64
+int NaClCopyCodeIter(uint8_t *dst, uint8_t *src,
+                     NaClPcAddress vbase, size_t size);
+#else
+#error "Unknown Platform"
+#endif
+
 #endif  /* NATIVE_CLIENT_SRC_TRUSTED_VALIDATOR_X86_COPYCODE_H_ */
 
Index: src/trusted/validator_x86/ncvalidate_iter.c
===================================================================
--- src/trusted/validator_x86/ncvalidate_iter.c	(revision 3669)
+++ src/trusted/validator_x86/ncvalidate_iter.c	(working copy)
@@ -14,7 +14,6 @@
 #include <string.h>
 
 #include "native_client/src/trusted/validator_x86/ncvalidate_iter.h"
-
 #include "native_client/src/shared/platform/nacl_log.h"
 #include "native_client/src/trusted/validator_x86/nc_inst_iter.h"
 #include "native_client/src/trusted/validator_x86/nc_inst_state_internal.h"
@@ -258,6 +257,40 @@
   }
 }
 
+void NaClValidatorTwoInstMessage(int level,
+                                 NaClValidatorState* state,
+                                 NaClInstState* inst1,
+                                 NaClInstState* inst2,
+                                 const char* format,
+                                 ...) {
+  level = NaClRecordIfValidatorError(state, level);
+  if (NaClPrintValidatorMessages(state, level)) {
+    va_list ap;
+    struct Gio* g = NaClLogGetGio();
+
+    NaClLogLock();
+    /* TODO(karl) - Make printing of instruction state possible via format. */
+    va_start(ap, format);
+    NaClLog_mu(level, "VALIDATOR: %s", NaClLogLevelLabel(level));
+    NaClLogV_mu(level, format, ap);
+    va_end(ap);
+
+    /* TODO(karl): empty fmt strings not allowed */
+    NaClLog_mu(level, "\n%45s ", "VALIDATOR:");
+    NaClInstStateInstPrint(g, inst1);
+    /* TODO(karl): empty fmt strings not allowed */
+    NaClLog_mu(level, "%45s ", "VALIDATOR:");
+    NaClInstStateInstPrint(g, inst2);
+
+    NaClLogUnlock();
+    NaClRecordErrorReported(state, level);
+  }
+  if (state->do_stub_out && (level <= LOG_ERROR)) {
+    memset(inst1->mpc, kNaClFullStop, inst1->length);
+    memset(inst2->mpc, kNaClFullStop, inst2->length);
+  }
+}
+
 Bool NaClValidatorQuit(NaClValidatorState* state) {
   return !state->validates_ok && (state->quit_after_error_count == 0);
 }
@@ -284,10 +317,12 @@
   defn->destroy_memory = destroy_memory;
 }
 
-NaClValidatorState* NaClValidatorStateCreate(const NaClPcAddress vbase,
-                                             const NaClMemorySize sz,
-                                             const uint8_t alignment,
-                                             const NaClOpKind base_register) {
+NaClValidatorState* NaClValidatorStateCreateInternal(const NaClPcAddress vbase,
+                                                     const NaClMemorySize sz,
+                                                     const uint8_t alignment,
+                                                     const NaClPcAddress text_start,
+                                                     const NaClMemorySize text_size,
+                                                     const NaClOpKind base_register) {
   NaClValidatorState* state;
   NaClValidatorState* return_value = NULL;
   NaClPcAddress vlimit = vbase + sz;
@@ -320,10 +355,33 @@
     state->cur_inst_vector = NULL;
     state->quit = NaClValidatorQuit(return_value);
     state->do_stub_out = FALSE;
+    state->text_start = text_start;
+    state->text_size = text_size;
+    state->allow_external_targets = FALSE;
   }
   return return_value;
 }
 
+INLINE void NaClValidatorStateAllowExternalTargets(NaClValidatorState* state) {
+  state->allow_external_targets = TRUE;
+}
+
+NaClValidatorState* NaClValidatorStateCreate(const NaClPcAddress vbase,
+                                             const NaClMemorySize sz,
+                                             const uint8_t alignment,
+                                             const NaClOpKind base_register) {
+  return NaClValidatorStateCreateInternal(vbase, sz, alignment, 0, 0, base_register);
+}
+
+NaClValidatorState* NaClValidatorStateCreateWithText(const NaClPcAddress vbase,
+                                                     const NaClMemorySize sz,
+                                                     const uint8_t alignment,
+                                                     const NaClPcAddress text_start,
+                                                     const NaClMemorySize text_size,
+                                                     const NaClOpKind base_register) {
+  return NaClValidatorStateCreateInternal(vbase, sz, alignment, text_start, text_size, base_register);
+}
+
 /* Add validators to validator state if missing. Assumed to be called just
  * before analyzing a code segment.
  */
@@ -449,3 +507,158 @@
   }
   return NULL;
 }
+
+/*
+ * Check that iter_new is a valid replacement for iter_old.
+ * If a validation error occurs, state->validates_ok will be set to false by
+ * NaClValidatorInstMessage when it is given LOG_ERROR, see the end of this
+ * function.
+ */
+static void NaClValidateInstReplacement(NaClInstIter* iter_old,
+                                        NaClInstIter* iter_new,
+                                        struct NaClValidatorState* state) {
+  NaClInstState *istate_old, *istate_new;
+  NaClExpVector *exp_old, *exp_new;
+  uint32_t i;
+
+  istate_old = NaClInstIterGetState(iter_old);
+  istate_new = NaClInstIterGetState(iter_new);
+
+  /* Location/length must match */
+  if (istate_new->vpc != istate_old->vpc ||
+      istate_new->length != istate_old->length) {
+    NaClValidatorTwoInstMessage(LOG_ERROR, state, istate_old, istate_new,
+          "Code modification: instructions length/addresses do not match");
+    return;
+  }
+
+
+  do {
+    /* fast check if the replacement is identical */
+    if (!memcmp(istate_old->mpc, istate_new->mpc, istate_old->length))
+      return;
+
+    if (istate_old->num_prefix_bytes != istate_new->num_prefix_bytes)
+      break;
+    if (istate_old->num_rex_prefixes != istate_new->num_rex_prefixes)
+      break;
+    if (istate_old->rexprefix != istate_new->rexprefix)
+      break;
+    if (istate_old->modrm != istate_new->modrm)
+      break;
+    if (istate_old->has_sib != istate_new->has_sib)
+      break;
+    if (istate_old->has_sib && istate_old->sib != istate_new->sib)
+      break;
+    if (istate_old->operand_size != istate_new->operand_size)
+      break;
+    if (istate_old->address_size != istate_new->address_size)
+      break;
+    if (istate_old->prefix_mask != istate_new->prefix_mask)
+      break;
+
+    /*
+     * these are pointers, but they reference entries in a static table,
+     * so if the two instructions are the same, then these pointers must
+     * reference the same entry
+     */
+    if (istate_old->inst != istate_new->inst)
+      break;
+
+    exp_old = NaClInstStateExpVector(istate_old);
+    exp_new = NaClInstStateExpVector(istate_new);
+
+    /* check if the instruction operands are identical */
+    if (exp_old->number_expr_nodes != exp_new->number_expr_nodes)
+      break;
+
+    for (i = 0; i < exp_old->number_expr_nodes; i++) {
+      if (exp_old->node[i].kind  != exp_new->node[i].kind)
+        break;
+      if (exp_old->node[i].flags != exp_new->node[i].flags)
+        break;
+
+      /*
+       * allow some constants to be different; however it is important not to
+       * allow modification of sandboxing instructions. Note nether of the
+       * instructions allowed for modification is used for sandboxing
+       */
+      if (exp_old->node[i].value != exp_new->node[i].value) {
+        if (exp_old->node[i].kind == ExprConstant) {
+
+          /* allow different constants in direct calls */
+          if (istate_old->inst->name == InstCall)
+            if (exp_old->node[i].flags & NACL_EFLAG(ExprJumpTarget))
+              if (exp_old->node[NaClGetExpParentIndex(exp_old, i)].kind
+                    == OperandReference)
+                continue;
+
+          /*
+           * allow different constants in operand of mov
+           * e.g. mov $rax, 0xdeadbeef
+           */
+          if (istate_old->inst->name == InstMov)
+            if (exp_old->node[i].flags & NACL_EFLAG(ExprUsed))
+              if (exp_old->node[NaClGetExpParentIndex(exp_old, i)].kind
+                    == OperandReference)
+                continue;
+          /*
+           * allow different displacements in memory reference of mov
+           * instructions e.g. mov $rax, [$r15+$rbx*2+0x7fff]
+           */
+          if (istate_old->inst->name == InstMov)
+            if (exp_old->node[NaClGetExpParentIndex(exp_old, i)].kind
+                    == ExprMemOffset)
+              /* displacement is the fourth node after ExprMemOffset node */
+              if (i - NaClGetExpParentIndex(exp_old, i) == 4)
+                continue;
+        }
+        break;
+      }
+    }
+
+    return;
+  } while (0);
+
+  NaClValidatorTwoInstMessage(LOG_ERROR, state, istate_old, istate_new,
+                      "Code modification: failed to modify instruction");
+}
+
+void NaClValidateSegmentPair(uint8_t* mbase_old, uint8_t* mbase_new,
+                           NaClPcAddress vbase, size_t size,
+                           struct NaClValidatorState* state) {
+  NaClSegment segment_old, segment_new;
+  NaClInstIter *iter_old, *iter_new;
+
+  NaClValidatorStateInitializeValidators(state);
+  NaClSegmentInitialize(mbase_old, vbase, size, &segment_old);
+  NaClSegmentInitialize(mbase_new, vbase, size, &segment_new);
+  iter_old = NaClInstIterCreateWithLookback(&segment_old, kLookbackSize);
+  iter_new = NaClInstIterCreateWithLookback(&segment_new, kLookbackSize);
+  while (NaClInstIterHasNext(iter_old) &&
+         NaClInstIterHasNext(iter_new)) {
+    state->cur_inst_state = NaClInstIterGetState(iter_new);
+    state->cur_inst = NaClInstStateInst(state->cur_inst_state);
+    state->cur_inst_vector = NaClInstStateExpVector(state->cur_inst_state);
+    NaClApplyValidators(state, iter_new);
+    NaClValidateInstReplacement(iter_old, iter_new, state);
+    if (state->quit) break;
+    NaClInstIterAdvance(iter_old);
+    NaClInstIterAdvance(iter_new);
+  }
+
+  if (NaClInstIterHasNext(iter_old) ||
+      NaClInstIterHasNext(iter_new)) {
+    NaClValidatorMessage(LOG_ERROR, state,
+    "Code modification: code segments have different number of instructions\n");
+  }
+
+  state->cur_inst_state = NULL;
+  state->cur_inst = NULL;
+  state->cur_inst_vector = NULL;
+  NaClApplyPostValidators(state, iter_new);
+  NaClInstIterDestroy(iter_old);
+  NaClInstIterDestroy(iter_new);
+  NaClValidatorStatePrintStats(state);
+}
+
Index: src/trusted/validator_x86/ncvalidate_internaltypes.h
===================================================================
--- src/trusted/validator_x86/ncvalidate_internaltypes.h	(revision 3669)
+++ src/trusted/validator_x86/ncvalidate_internaltypes.h	(working copy)
@@ -45,6 +45,12 @@
   uint32_t opcodehisto[256];
   uint8_t *vttable;
   uint8_t *kttable;
+  uint8_t *ettable;
+  uintptr_t region_start;
+  size_t region_size;
+  uintptr_t text_base;
+  bool allow_external_targets;
+  bool enable_external_targets;
   int do_stub_out;  /* boolean */
   int num_diagnostics; /* How many error messages to print. */
 };
Index: src/trusted/validator_x86/ncvalidate_iter.h
===================================================================
--- src/trusted/validator_x86/ncvalidate_iter.h	(revision 3669)
+++ src/trusted/validator_x86/ncvalidate_iter.h	(working copy)
@@ -82,6 +82,16 @@
                                              const uint8_t alignment,
                                              const NaClOpKind base_register);
 
+NaClValidatorState* NaClValidatorStateCreateWithText(const NaClPcAddress vbase,
+                                                     const NaClMemorySize sz,
+                                                     const uint8_t alignment,
+                                                     const NaClPcAddress nap_pbase,
+                                                     const NaClMemorySize nap_size,
+                                                     const NaClOpKind base_register);
+
+/* Disables check of external jump targets */
+void NaClValidatorStateAllowExternalTargets(NaClValidatorState* state);
+
 /* Returns the current maximum number of errors that can be reported.
  * Note: When > 0, the validator will only print that many errors before
  * quiting. When 0, the validator will not print any messages. When < 0,
@@ -195,6 +205,46 @@
                          NaClMemorySize sz,
                          NaClValidatorState* state);
 
+/*
+ * Validate a segment for dynamic code replacement
+ * Checks if code at mbase_old can be replaced with code at mbase_new
+ * Note that mbase_old was validated when it was inserted originally.
+ * If validation fails, state->validates_ok will be set to false.
+ * Parameters:
+ *    mbase_old - The address of the beginning of the code segment to be
+ *                replaced
+ *    mbase_new - The address of the code segment that replaces the old
+ *                segment
+ *    vbase     - Virtual address that is associated with both segments
+ *    size      - Length of the code segments (the segments must be of the same
+ *                size)
+ *    state     - The validator state to use while validating *new* segment
+ */
+void NaClValidateSegmentPair(uint8_t *mbase_old,
+                             uint8_t *mbase_new,
+                             NaClPcAddress vbase,
+                             size_t size,
+                             struct NaClValidatorState *state);
+
+/* Validate a segment for dynamic code replacement
+ * Checks if code at mbase_old can be replaced with code at mbase_new
+ * Note that mbase_old was validated when it was inserted originally
+ * Parameters:
+ *    mbase_old - The address of the beginning of the code segment to be
+ *                replaced
+ *    mbase_new - The address of the code segment that replaces the old
+ *                segment
+ *    vbase     - Virtual address that is associated with both segments
+ *    size      - Length of the code segments (the segments must be of the same
+ *                size)
+ *    state     - The validator state to use while validating *new* segment
+ */
+void NaClValidateSegmentPair(uint8_t *mbase_old,
+                             uint8_t *mbase_new,
+                             NaClPcAddress vbase,
+                             size_t size,
+                             struct NaClValidatorState *state);
+
 /* Returns true if the validator hasn't found any problems with the validated
  * code segments.
  * Parameters:
@@ -346,6 +396,22 @@
                               const char* format,
                               ...) ATTRIBUTE_FORMAT_PRINTF(4, 5);
 
+/* Prints out a validator message and two given instructions.
+ * Parameters:
+ *   level - The level of the message, as defined in nacl_log.h
+ *   state - The validator state that detected the error.
+ *   inst1 - The first instruction to be printed.
+ *   inst2 - The second instruction to be printed.
+ *   format - The format string of the message to print.
+ *   ... - arguments to the format string.
+ */
+void NaClValidatorTwoInstMessage(int level,
+                                 NaClValidatorState* state,
+                                 NaClInstState* inst1,
+                                 NaClInstState* inst2,
+                                 const char* format,
+                                 ...) ATTRIBUTE_FORMAT_PRINTF(5, 6);
+
 /* Returns true if the validator should quit due to previous errors. */
 Bool NaClValidatorQuit(NaClValidatorState* state);
 
Index: src/trusted/validator_x86/nc_jumps.c
===================================================================
--- src/trusted/validator_x86/nc_jumps.c	(revision 3669)
+++ src/trusted/validator_x86/nc_jumps.c	(working copy)
@@ -19,6 +19,10 @@
 #include "native_client/src/trusted/validator_x86/ncvalidate_iter.h"
 #include "native_client/src/trusted/validator_x86/ncvalidate_iter_internal.h"
 
+#include "native_client/src/shared/platform/nacl_check.h"
+#include "native_client/src/trusted/validator_x86/nc_segment.h"
+#include "native_client/src/trusted/validator_x86/nc_inst_state_internal.h"
+
 /* To turn on debugging of instruction decoding, change value of
  * DEBUGGING to 1.
  */
@@ -142,6 +146,10 @@
    * the call to NaClJumpValidator.
    */
   NaClAddressSet removed_targets;
+  /* Jump/call instructions that have external targets, targets that are outside
+   * of the validated code segment.
+   */
+  NaClAddressSet external_sources;
   /* Holds the (array) size of each set above. */
   size_t set_array_size;
 } NaClJumpSets;
@@ -162,12 +170,24 @@
         jump_sets->removed_targets == NULL) {
       NaClValidatorMessage(LOG_FATAL, state, "unable to allocate jump sets");
     }
+    jump_sets->external_sources = NULL;
     jump_sets->set_array_size =
         NaClAddressSetArraySize(state->vlimit - align_base);
   }
   return jump_sets;
 }
 
+static void AllocateExternalJumpSet(NaClJumpSets* jump_sets,
+                                    NaClValidatorState* state) {
+  NaClPcAddress align_base = state->vbase & (~state->alignment);
+  CHECK(jump_sets->external_sources == NULL);
+  jump_sets->external_sources =
+        NaClAddressSetCreate(state->vlimit - align_base);
+  if (jump_sets->external_sources == NULL) {
+    NaClValidatorMessage(LOG_FATAL, state, "unable to allocate external jump set");
+  }
+}
+
 /* Record that there is an explicit jump from the from_address to the
  * to_address, for the validation defined by the validator state.
  * Parameters:
@@ -201,11 +221,18 @@
    * hurt to disallow branches that overflow or underflow the address
    * space.
    */
-  else if ((to_address & state->alignment_mask) == 0 &&
-           (to_address & ~(NaClPcAddress) 0xffffffff) == 0) {
+  else if ((to_address & state->alignment_mask) == 0) {
     /* Allow bundle-aligned jump. */
   }
-  else {
+  else if (((to_address & ~(NaClPcAddress) 0xffffffff) == 0) &&
+           (to_address >= (state->text_start & 0xffffffff)) &&
+           (to_address < (state->text_start & 0xffffffff) + state->text_size)) {
+    if (state->allow_external_targets == TRUE)
+      return;
+    if (jump_sets->external_sources == NULL)
+      AllocateExternalJumpSet(jump_sets, state);
+    NaClAddressSetAdd(jump_sets->external_sources, from_address, state);
+  } else {
     NaClValidatorInstMessage(LOG_ERROR, state, inst,
                              "Instruction jumps to bad address\n");
   }
@@ -540,6 +567,26 @@
   }
 }
 
+static NaClPcAddress NaClGetExprJumpTarget(NaClValidatorState* state,
+                                           NaClInstIter* iter) {
+  uint32_t i;
+  NaClInstState* inst_state = NaClInstIterGetState(iter);
+  NaClExpVector* vector = NaClInstStateExpVector(inst_state);
+
+  DEBUG(NaClLog(LOG_INFO, "external jump checking: ");
+        NaClInstStateInstPrint(NaClLogGetGio(), inst_state));
+
+  for (i = 0; i < vector->number_expr_nodes; ++i)
+    if (vector->node[i].flags & NACL_EFLAG(ExprJumpTarget))
+      if ((vector->node[i].kind == ExprConstant) ||
+          (vector->node[i].kind == ExprConstant64))
+          return (NaClPcAddress)NaClGetExpConstant(vector, i);
+
+  NaClValidatorInstMessage(LOG_ERROR, state, inst_state,
+                           "Not a direct jump\n");
+  return (NaClPcAddress) NULL;
+}
+
 /* Given an instruction corresponding to a call, validate that the generated
  * return address is safe.
  * Parameters:
@@ -647,6 +694,50 @@
       !NaClAddressSetContains(jump_sets->removed_targets, addr, state);
 }
 
+static NaClJumpSets *NaClValidatorStateGetJumpSets(NaClValidatorState *state) {
+  int i;
+  NaClValidatorDefinition* defn;
+
+  for (i = 0; i < state->number_validators; i++) {
+    defn = &state->validators[i];
+    if (defn->validator == (NaClValidator)NaClJumpValidator)
+      return state->local_memory[i];
+  }
+  return NULL;
+}
+
+static void NaClValidateExternalTarget(NaClValidatorState *state,
+                                       NaClPcAddress source,
+                                       NaClPcAddress target) {
+  NaClPcAddress bundle_start = target & ~state->alignment_mask;
+  NaClValidatorState *local_state;
+  NaClJumpSets* jump_sets;
+
+  CHECK(state->text_size);
+  local_state = NaClValidatorStateCreateWithText((uintptr_t)(bundle_start),
+                                                 state->alignment,
+                                                 state->alignment,
+                                                 state->text_start,
+                                                 state->text_size,
+                                                 state->base_register);
+  NaClValidatorStateAllowExternalTargets(local_state);
+  NaClValidatorStateSetLogVerbosity(local_state, LOG_ERROR);
+  NaClValidateSegment((uint8_t*)((state->text_start & ~0xffffffffL) + bundle_start), 
+                      bundle_start,
+                      local_state->alignment,
+                      local_state);
+ 
+  jump_sets = NaClValidatorStateGetJumpSets(local_state);
+  CHECK(jump_sets);
+  if (IsNaClReachableAddress(local_state, target, jump_sets))
+    return;
+  
+  NaClValidatorStateDestroy(local_state);
+
+  NaClValidatorPcAddressMessage(LOG_ERROR, state, source,
+                                "Bad jump target\n");
+}
+
 void NaClJumpValidatorSummarize(NaClValidatorState* state,
                                 NaClInstIter* iter,
                                 NaClJumpSets* jump_sets) {
@@ -709,6 +800,36 @@
     }
   }
 
+  if (!state->allow_external_targets && jump_sets->external_sources) {
+    for (i = 0; i < jump_sets->set_array_size; ++i) {
+      if (jump_sets->external_sources[i]) {
+        NaClPcAddress j;
+        NaClPcAddress base = (i << 3) + state->vbase;
+        for (j = 0; j < 8; ++j) {
+          addr = base + j;
+          if (addr < state->vlimit) {
+            if (NaClAddressSetContains(jump_sets->external_sources, addr, state)) {
+              if (state->text_size) {
+                NaClSegment segment;
+                NaClInstIter *iter;
+                NaClPcAddress target;
+                NaClSegmentInitialize((uint8_t*)((state->text_start & ~0xffffffffL) + addr), addr, state->alignment, &segment);
+                iter = NaClInstIterCreate(&segment);
+                target = NaClGetExprJumpTarget(state, iter);
+                NaClInstIterDestroy(iter);
+                if (!target) continue;
+                NaClValidateExternalTarget(state, addr, target);
+              } else {
+                NaClValidatorPcAddressMessage(LOG_ERROR, state, addr,
+                                            "Bad jump target\n");
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+
   /* Check that all block boundaries are accessable at an aligned address. */
   NaClValidatorMessage(
       LOG_INFO, state, "Checking that basic blocks are aligned\n");
@@ -735,6 +856,8 @@
   NaClAddressSetDestroy(jump_sets->actual_targets);
   NaClAddressSetDestroy(jump_sets->possible_targets);
   NaClAddressSetDestroy(jump_sets->removed_targets);
+  if (jump_sets->external_sources)
+    NaClAddressSetDestroy(jump_sets->external_sources);
   free(jump_sets);
 }
 
Index: src/trusted/service_runtime/nacl_syscall_common.c
===================================================================
--- src/trusted/service_runtime/nacl_syscall_common.c	(revision 3669)
+++ src/trusted/service_runtime/nacl_syscall_common.c	(working copy)
@@ -126,6 +126,7 @@
 void NaClSysCommonThreadSyscallLeave(struct NaClAppThread *natp) {
   NaClXMutexLock(&natp->mu);
   natp->holding_sr_locks = 0;
+  natp->dynamic_delete_generation = natp->nap->dynamic_delete_generation;
   switch (natp->state) {
     case NACL_APP_THREAD_ALIVE:
       break;
Index: src/trusted/service_runtime/sel_validate_image.c
===================================================================
--- src/trusted/service_runtime/sel_validate_image.c	(revision 3669)
+++ src/trusted/service_runtime/sel_validate_image.c	(working copy)
@@ -10,10 +10,11 @@
 
 #if NACL_ARCH(NACL_BUILD_ARCH) == NACL_x86
 
+# include "native_client/src/trusted/validator_x86/nccopycode.h"
+
 # if NACL_TARGET_SUBARCH == 32
 
 #  include "native_client/src/trusted/validator_x86/ncvalidate.h"
-#  include "native_client/src/trusted/validator_x86/nccopycode.h"
 
 int NaClValidateCode(struct NaClApp *nap, uintptr_t guest_addr,
                      uint8_t *data, size_t size) {
@@ -49,7 +50,8 @@
 
 int NaClValidateCodeReplacement(struct NaClApp *nap, uintptr_t guest_addr,
                                 uint8_t *data_old, uint8_t *data_new,
-                                size_t size) {
+                                size_t size, uintptr_t region_start,
+                                size_t region_size) {
   struct NCValidatorState *vstate;
   int validator_result;
 
@@ -59,7 +61,11 @@
     return LOAD_BAD_FILE;
   }
 
-  vstate = NCValidateInit(guest_addr, guest_addr + size, nap->bundle_size);
+  vstate = NCValidateInitWithExternalTargets(guest_addr,
+                                             guest_addr+size, nap->bundle_size,
+                                             region_start,
+                                             region_size,
+                                             nap->mem_start);
   if (vstate == NULL) {
     return LOAD_BAD_FILE;
   }
@@ -97,6 +103,7 @@
   if (vstate == NULL) {
     return LOAD_BAD_FILE;
   }
+
   NaClValidatorStateSetLogVerbosity(vstate, LOG_ERROR);
 
   if (nap->validator_stub_out_mode) {
@@ -123,29 +130,52 @@
 
 int NaClValidateCodeReplacement(struct NaClApp *nap, uintptr_t guest_addr,
                                 uint8_t *data_old, uint8_t *data_new,
-                                size_t size) {
-  UNREFERENCED_PARAMETER(nap);
-  UNREFERENCED_PARAMETER(guest_addr);
-  UNREFERENCED_PARAMETER(data_old);
-  UNREFERENCED_PARAMETER(data_new);
-  UNREFERENCED_PARAMETER(size);
-  NaClLog(1, "NaClValidateCodeReplacement: "
-             "code replacement not yet supported on x86_64\n");
-  return LOAD_UNIMPLEMENTED;
+                                size_t size, uintptr_t region_start,
+                                size_t region_size) {
+  struct NaClValidatorState *vstate;
+  int is_ok;
+
+  /* non-bundle-aligned external targets can be allowed only within current
+   * region, as the region is a unit of dynamic creation and deletion. If the
+   * external targets are allowed to land in other regions, there is a security
+   * risk as the target will be validated against current region, but the region
+   * can be replaced later, and the external target can land to a middle of
+   * instruction
+   */
+  vstate = NaClValidatorStateCreateWithText(guest_addr, size, nap->bundle_size,
+                                            region_start,
+                                            region_size,
+                                            RegR15);
+  if (vstate == NULL) {
+    return LOAD_BAD_FILE;
+  }
+  NaClValidatorStateSetLogVerbosity(vstate, LOG_ERROR);
+
+  if (nap->validator_stub_out_mode) {
+    NaClLog(1, "NaClValidateCodeReplacement:  "
+               "stub_out_mode not supported for code replacement\n");
+    return LOAD_BAD_FILE;
+  }
+  NaClValidateSegmentPair(data_old, data_new, guest_addr, size, vstate);
+  is_ok = NaClValidatesOk(vstate);
+  NaClValidatorStateDestroy(vstate);
+  if (!is_ok) {
+    return LOAD_VALIDATION_FAILED;
+  }
+  return LOAD_OK;
 }
 
-
 int NaClCopyCode(struct NaClApp *nap, uintptr_t guest_addr,
                  uint8_t *data_old, uint8_t *data_new,
                  size_t size) {
+  int result;
   UNREFERENCED_PARAMETER(nap);
-  UNREFERENCED_PARAMETER(guest_addr);
-  UNREFERENCED_PARAMETER(data_old);
-  UNREFERENCED_PARAMETER(data_new);
-  UNREFERENCED_PARAMETER(size);
-  NaClLog(1, "NaClCopyCode: "
-             "code replacement not yet supported on x86_64\n");
-  return LOAD_UNIMPLEMENTED;
+
+  result = NaClCopyCodeIter(data_old, data_new, guest_addr, size);
+  if (result != 0) {
+    return LOAD_UNLOADABLE;
+  }
+  return LOAD_OK;
 }
 
 # endif
Index: src/trusted/service_runtime/nacl_text.c
===================================================================
--- src/trusted/service_runtime/nacl_text.c	(revision 3669)
+++ src/trusted/service_runtime/nacl_text.c	(working copy)
@@ -400,6 +400,9 @@
   for (i = 0; i < nap->num_threads; ++i) {
     struct NaClAppThread *thread = NaClGetThreadMu(nap, i);
     NaClMutexLock(&thread->mu);
+    if (thread->holding_sr_locks) {
+      thread->dynamic_delete_generation = nap->dynamic_delete_generation;
+    }
     if (i == 0 || rv > thread->dynamic_delete_generation) {
       rv = thread->dynamic_delete_generation;
     }
@@ -757,7 +760,7 @@
   int                         validator_result;
   int32_t                     retval = -NACL_ABI_EINVAL;
   struct NaClDynamicRegion    *region;
-
+  
   if (NULL == nap->text_shm) {
     NaClLog(1, "NaClTextSysDyncode_Modify: Dynamic loading not enabled\n");
     return -NACL_ABI_EINVAL;
@@ -783,6 +786,16 @@
 
   NaClMutexLock(&nap->dynamic_load_mutex);
 
+/*
+ * NCValidateInit: Initialize NaCl validator internal state
+ * Parameters:
+ *    vbase: base virtual address for code segment
+ *    vlimit: size in bytes of code segment
+ *    alignment: 16 or 32, specifying alignment
+ * Returns:
+ *    an initialized struct NCValidatorState * if everything is okay,
+ *    else NULL
+ */
   region = NaClDynamicRegionFind(nap, dest_addr, size);
   if (NULL == region || region->start > dest_addr
         || region->start + region->size < dest_addr + size) {
@@ -829,7 +842,9 @@
                                                  dest,
                                                  (uint8_t*) dest_addr,
                                                  code_copy,
-                                                 size);
+                                                 size,
+                                                 region->start,
+                                                 region->size);
 
   if (validator_result != LOAD_OK
       && nap->ignore_validator_result) {
Index: src/trusted/service_runtime/sel_ldr.h
===================================================================
--- src/trusted/service_runtime/sel_ldr.h	(revision 3669)
+++ src/trusted/service_runtime/sel_ldr.h	(working copy)
@@ -318,7 +318,9 @@
                                 uintptr_t guest_addr,
                                 uint8_t   *data_old,
                                 uint8_t   *data_new,
-                                size_t    size);
+                                size_t    size,
+                                uintptr_t region_start,
+                                size_t    region_size);
 
 /*
  * Copies code from data_new to data_old in a thread-safe way
Index: src/trusted/platform_qualify/posix/nacl_dep_qualify.c
===================================================================
--- src/trusted/platform_qualify/posix/nacl_dep_qualify.c	(revision 3669)
+++ src/trusted/platform_qualify/posix/nacl_dep_qualify.c	(working copy)
@@ -16,6 +16,12 @@
 #include "native_client/src/trusted/platform_qualify/nacl_dep_qualify.h"
 #include "native_client/src/trusted/platform_qualify/linux/sysv_shm_and_mmap.h"
 
+#if NACL_OSX && NACL_BUILD_ARCH == NACL_x86 && NACL_BUILD_SUBARCH == 64
+# define EXPECTED_SIGNAL SIGBUS
+#else
+# define EXPECTED_SIGNAL SIGSEGV
+#endif
+
 static struct sigaction previous_sigaction;
 static struct sigaction try_sigaction;
 static sigjmp_buf try_state;
@@ -29,11 +35,11 @@
   sigemptyset(&try_sigaction.sa_mask);
   try_sigaction.sa_flags = SA_RESETHAND;
 
-  (void) sigaction(SIGSEGV, &try_sigaction, &previous_sigaction);
+  (void) sigaction(EXPECTED_SIGNAL, &try_sigaction, &previous_sigaction);
 }
 
 static void restore_signals() {
-  (void) sigaction(SIGSEGV, &previous_sigaction, 0);
+  (void) sigaction(EXPECTED_SIGNAL, &previous_sigaction, 0);
 }
 
 /*
Index: tests/inbrowser_test_runner/nacl.scons
===================================================================
--- tests/inbrowser_test_runner/nacl.scons	(revision 3669)
+++ tests/inbrowser_test_runner/nacl.scons	(working copy)
@@ -17,6 +17,7 @@
 dest_copy = env.Replicate('$STAGING_DIR', 'test_runner.html')
 test_executables = [
     env.File('$STAGING_DIR/dynamic_load_test.nexe'),
+    env.File('$STAGING_DIR/dynamic_modify_test.nexe'),
     env.File('$STAGING_DIR/imc_shm_mmap_test.nexe'),
     ]
 # These are not true dependencies: They are not needed for
Index: tests/inbrowser_test_runner/test_runner.html
===================================================================
--- tests/inbrowser_test_runner/test_runner.html	(revision 3669)
+++ tests/inbrowser_test_runner/test_runner.html	(working copy)
@@ -111,6 +111,7 @@
   }
 
   addTest('dynamic_load_test.nexe');
+  addTest('dynamic_modify_test.nexe');
   addTest('imc_shm_mmap_test.nexe');
 }
 
Index: tests/dynamic_code_loading/nacl.scons
===================================================================
--- tests/dynamic_code_loading/nacl.scons	(revision 3669)
+++ tests/dynamic_code_loading/nacl.scons	(working copy)
@@ -38,10 +38,10 @@
                       template_obj],
                      EXTRA_LIBS=['testrunner', 'srpc', 'pthread'])
 
-# Uncomment once the toolchain gets the new syscalls:
-#env.ComponentProgram('dynamic_modify_test.nexe',
-#                     ['dynamic_modify_test.c',
-#                      template_obj])
+env.ComponentProgram('dynamic_modify_test.nexe',
+                     ['dynamic_modify_test.c',
+                      template_obj],
+                     EXTRA_LIBS=['testrunner', 'srpc', 'pthread'])
 
 env.ComponentProgram('write_to_dyncode.nexe',
                      ['write_to_dyncode.c'])
@@ -80,16 +80,16 @@
         sel_ldr_flags=["-c"],
         command=[env.File('debug_mode_test.nexe')],
         ),
-# Uncomment once the toolchain gets the new syscalls:
-#   env.CommandSelLdrTestNacl(
-#       'dynamic_modify_test_disabled.out',
-#       command=[env.File('dynamic_modify_test.nexe')],
-#       ),
-#   env.CommandSelLdrTestNacl(
-#       'dynamic_modify_test_enabled.out',
-#       command=[env.File('dynamic_modify_test.nexe')],
-#       osenv='NACL_ALLOW_DYNCODE_REPLACEMENT=1',
-#       ),
+   env.CommandSelLdrTestNacl(
+       'dynamic_modify_test_disabled.out',
+       command=[env.File('dynamic_modify_test.nexe')],
+       osenv='NACL_SRPC_STANDALONE=1',
+       ),
+   env.CommandSelLdrTestNacl(
+       'dynamic_modify_test_enabled.out',
+       command=[env.File('dynamic_modify_test.nexe')],
+       osenv='NACL_ALLOW_DYNCODE_REPLACEMENT=1,NACL_SRPC_STANDALONE=1',
+       ),
   ]
 
 # TODO(kcc): non-standard linking options confuse Valgrind debug info reader.
Index: tests/dynamic_code_loading/dynamic_load_test.c
===================================================================
--- tests/dynamic_code_loading/dynamic_load_test.c	(revision 3669)
+++ tests/dynamic_code_loading/dynamic_load_test.c	(working copy)
@@ -17,7 +17,23 @@
 #include "native_client/tests/dynamic_code_loading/templates.h"
 #include "native_client/tests/inbrowser_test_runner/test_runner.h"
 
+#if defined(__x86_64__)
+/* On x86-64, template functions do not fit in 32-byte buffers */
+#define BUF_SIZE 64
+#elif defined(__i386__) || defined(__arm__)
+#define BUF_SIZE 32
+#else
+#error "Unknown Platform"
+#endif
+
+#if defined(__i386__) || defined(__x86_64__)
 #define NACL_BUNDLE_SIZE  32
+#elif defined(__arm__)
+#define NACL_BUNDLE_SIZE  16
+#else
+#error "Unknown Platform"
+#endif
+
 /*
  * TODO(bsy): get this value from the toolchain.  Get the toolchain
  * team to provide this value.
@@ -93,8 +109,8 @@
                            const char *fragment_start,
                            const char *fragment_end) {
   int fragment_size = fragment_end - fragment_start;
-  assert(dest_size % 32 == 0);
-  assert(fragment_size < dest_size);
+  assert(dest_size % NACL_BUNDLE_SIZE == 0);
+  assert(fragment_size <= dest_size);
   fill_nops(dest, dest_size);
   memcpy(dest, fragment_start, fragment_size);
 }
@@ -102,7 +118,7 @@
 /* Check that we can load and run code. */
 void test_loading_code() {
   void *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
   int (*func)();
 
@@ -124,7 +140,7 @@
    Check that we can load to non-page-aligned addresses. */
 void test_loading_code_non_page_aligned() {
   char *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
 
   copy_and_pad_fragment(buf, sizeof(buf), &template_func, &template_func_end);
@@ -133,7 +149,7 @@
   assert(rc == 0);
   assert(memcmp(load_area, buf, sizeof(buf)) == 0);
 
-  load_area += 32;
+  load_area += sizeof(buf);
   rc = nacl_load_code(load_area, buf, sizeof(buf));
   assert(rc == 0);
   assert(memcmp(load_area, buf, sizeof(buf)) == 0);
@@ -163,7 +179,7 @@
 void test_loading_code_on_first_dynamic_page() {
   const unsigned int kPageMask = 0xFFFF;
   void *load_area = (void*)((uintptr_t)(etext + kPageMask) & ~kPageMask);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
   int (*func)();
 
@@ -186,7 +202,7 @@
 
 void test_fail_on_validation_error() {
   void *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
 
   copy_and_pad_fragment(buf, sizeof(buf), &invalid_code, &invalid_code_end);
@@ -198,24 +214,24 @@
 void test_fail_on_non_bundle_aligned_dest_addresses() {
   char *load_area = allocate_code_space(1);
   int rc;
-  uint8_t nops[32];
+  uint8_t nops[BUF_SIZE];
 
   fill_nops(nops, sizeof(nops));
 
   /* Test unaligned destination. */
-  rc = nacl_load_code(load_area + 1, nops, 32);
+  rc = nacl_load_code(load_area + 1, nops, NACL_BUNDLE_SIZE);
   assert(rc == -EINVAL);
-  rc = nacl_load_code(load_area + 4, nops, 32);
+  rc = nacl_load_code(load_area + 4, nops, NACL_BUNDLE_SIZE);
   assert(rc == -EINVAL);
 
   /* Test unaligned size. */
-  rc = nacl_load_code(load_area, nops + 1, 31);
+  rc = nacl_load_code(load_area, nops + 1, NACL_BUNDLE_SIZE - 1);
   assert(rc == -EINVAL);
-  rc = nacl_load_code(load_area, nops + 4, 28);
+  rc = nacl_load_code(load_area, nops + 4, NACL_BUNDLE_SIZE - 4);
   assert(rc == -EINVAL);
 
   /* Check that the code we're trying works otherwise. */
-  rc = nacl_load_code(load_area, nops, 32);
+  rc = nacl_load_code(load_area, nops, NACL_BUNDLE_SIZE);
   assert(rc == 0);
 }
 
@@ -235,18 +251,18 @@
 
   fill_hlts(block_in_data_segment, sizeof(block_in_data_segment));
 
-  /* Align to 32 byte boundary so that we don't fail for a reason
+  /* Align to bundle size so that we don't fail for a reason
      we're not testing for. */
   data = block_in_data_segment;
-  while (((int) data) % 32 != 0)
+  while (((int) data) % NACL_BUNDLE_SIZE != 0)
     data++;
-  rc = nacl_load_code(data, data, 32);
+  rc = nacl_load_code(data, data, NACL_BUNDLE_SIZE);
   assert(rc == -EFAULT);
 }
 
 void test_fail_on_overwrite() {
   void *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
 
   copy_and_pad_fragment(buf, sizeof(buf), &template_func, &template_func_end);
@@ -298,7 +314,7 @@
 void test_end_of_code_region() {
   int rc;
   void *dest;
-  uint8_t data[32];
+  uint8_t data[BUF_SIZE];
   fill_nops(data, sizeof(data));
 
   /* This tries to load into the data segment, which is definitely not
Index: tests/dynamic_code_loading/templates.h
===================================================================
--- tests/dynamic_code_loading/templates.h	(revision 3669)
+++ tests/dynamic_code_loading/templates.h	(working copy)
@@ -19,6 +19,14 @@
 extern char branch_forwards_end;
 extern char branch_backwards;
 extern char branch_backwards_end;
+extern char template_func_misaligned_replacement;
+extern char template_func_misaligned_replacement_end;
+extern char template_func_illegal_call_target;
+extern char template_func_illegal_call_target_end;
+extern char template_func_illegal_register_replacement;
+extern char template_func_illegal_register_replacement_end;
+extern char template_func_illegal_guard_replacement;
+extern char template_func_illegal_guard_replacement_end;
 
 /*
  * The end of the text segment, the dynamic code resion starts at the
Index: tests/dynamic_code_loading/templates_x86.S
===================================================================
--- tests/dynamic_code_loading/templates_x86.S	(revision 3669)
+++ tests/dynamic_code_loading/templates_x86.S	(working copy)
@@ -10,52 +10,94 @@
 #if defined(__i386__)
         movl $1234, %eax
         popl %ecx
-        nacljmp %ecx
+        and  $0xffffffe0,%ecx
+        jmp  *%ecx
+        call template_func
 #elif defined(__x86_64__)
+        disp = template_func_end - 4
+        xorl %r11d, %r11d
+        movq disp(%r15,%r11,1), %rax
+        popq %r14
+        andl $0xffffffe0,%r14d
+        addq %r15,%r14
+        jmpq *%r14
+        call template_func
         movq $1234, %rax
-        popq %r11
-        nacljmp %r11d, %r15
 #else
 # error "Unsupported architecture"
 #endif
 template_func_end:
 
+
         .global template_func_replacement
         .global template_func_replacement_end
         .p2align 5
 template_func_replacement:
 #if defined(__i386__)
-        movl $4321, %eax
+        movl $4321, %eax                       /* replaces constant */
         popl %ecx
-        nacljmp %ecx
+        and  $0xffffffe0,%ecx
+        jmp  *%ecx
+        call (template_func_replacement - 32)  /* replaces a call target, the
+                                                * new target is bundle aligned
+                                                * and target address outside
+                                                * modified section */
 #elif defined(__x86_64__)
-        movq $4321, %rax
-        popq %r11
-        nacljmp %r11d, %r15
+        /* tests all modifications that are
+         * currently allowed by service runtime */
+        new_disp = template_func_replacement_end - 4
+        xorl %r11d, %r11d
+        movq new_disp(%r15,%r11,1), %rax       /* replaces displacement */
+        popq %r14
+        andl $0xffffffe0,%r14d
+        addq %r15,%r14
+        jmpq *%r14
+        call (template_func_replacement - 32)  /* replaces a call target, the
+                                                * new target is bundle aligned
+                                                * and target address outside
+                                                * modified section  */
+        movq $4321, %rax                       /* replaces constant */
 #else
 # error "Unsupported architecture"
 #endif
 template_func_replacement_end:
 
+
         .global template_func_nonreplacement
         .global template_func_nonreplacement_end
+        .global template_func_misaligned_replacement
+        .global template_func_misaligned_replacement_end
         .p2align 5
 template_func_nonreplacement:
+template_func_misaligned_replacement:
 #if defined(__i386__)
-        movl $4132, %eax
-        popl %edx
-        nacljmp %edx
+        nop                                    /* nop creates misalignment in
+                                                * replacing section which makes
+                                                * it illegal */
+        movl $1234, %eax
+        popl %ecx
+        and  $0xffffffe0,%ecx
+        jmp  *%ecx
+        call template_func_misaligned_replacement
 #elif defined(__x86_64__)
-        movq $4132, %rax
-        popq %r12
-        nacljmp %r12d, %r15
+        nop                                    /* nop creates misalignment in
+                                                * replacing section which makes
+                                                * it illegal */
+        xorl %r11d, %r11d
+        movq disp(%r15,%r11,1), %rax
+        popq %r14
+        andl $0xffffffe0,%r14d
+        addq %r15,%r14
+        jmpq *%r14
+        call template_func_misaligned_replacement
+        movq $1234, %rax
 #else
 # error "Unsupported architecture"
 #endif
+template_func_misaligned_replacement_end:
 template_func_nonreplacement_end:
 
 
-
         .global hlts
         .global hlts_end
         .p2align 5
@@ -83,8 +125,8 @@
 branch_backwards_end:
 
 
-       /* We include disallowed code below, so this must go into the
-          data segment. */
+        /* We include disallowed code below, so this must go into the
+           data segment. */
         .data
 
 
@@ -95,3 +137,86 @@
         int $0x80
         ret
 invalid_code_end:
+
+
+        .global template_func_illegal_register_replacement
+        .global template_func_illegal_register_replacement_end
+        .p2align 5
+template_func_illegal_register_replacement:
+#if defined(__i386__)
+        movl $1234, %eax
+        popl %ecx
+        and  $0xffffffe0,%ecx
+        jmp  *%edx                             /* replaces register here, jmp
+                                                * becomes illegal */
+        call template_func_illegal_register_replacement
+#elif defined(__x86_64__)
+        xorl %r11d, %r11d
+        movq disp(%r15,%r11,1), %rax
+        popq %r14
+        andl $0xffffffe0,%r14d
+        addq %r15,%r14
+        jmpq *%r14
+        call template_func_illegal_register_replacement
+        movq $1234, %rbx                       /* replaces register
+                                                * which is not allowed */
+#else
+# error "Unsupported architecture"
+#endif
+template_func_illegal_register_replacement_end:
+
+
+        .global template_func_illegal_guard_replacement
+        .global template_func_illegal_guard_replacement_end
+        .p2align 5
+template_func_illegal_guard_replacement:
+#if defined(__i386__)
+        movl $1234, %eax
+        popl %ecx
+        and  $0xffffffff,%ecx                  /* modifies mask */
+        jmp  *%ecx
+        call template_func_illegal_guard_replacement
+#elif defined(__x86_64__)
+        xorl %r14d, %r14d                      /* modifies memory guard */
+        movq disp(%r15,%r11,1), %rax
+        popq %r14
+        andl $0xffffffe0,%r14d
+        addq %r15,%r14
+        jmpq *%r14
+        call template_func_illegal_guard_replacement
+        movq $1234, %rax
+#else
+# error "Unsupported architecture"
+#endif
+template_func_illegal_guard_replacement_end:
+
+
+        .global template_func_illegal_call_target
+        .global template_func_illegal_call_target_end
+        .p2align 5
+template_func_illegal_call_target:
+#if defined(__i386__)
+        movl $1234, %eax
+        popl %ecx
+        and  $0xffffffe0,%ecx
+        jmp  *%ecx
+        call (template_func_illegal_call_target - 31)  /* target of a call
+                                                * instruction is beyond
+                                                * replaced section, and it is
+                                                * not bundle_aligned */
+#elif defined(__x86_64__)
+        xorl %r11d, %r11d
+        movq disp(%r15,%r11,1), %rax
+        popq %r14
+        andl $0xffffffe0,%r14d
+        addq %r15,%r14
+        jmpq *%r14
+        call (template_func_illegal_call_target - 31)  /* target of a call
+                                                * instruction is beyond
+                                                * replaced section, and it is
+                                                * not bundle_aligned */
+        movq $1234, %rax
+#else
+# error "Unsupported architecture"
+#endif
+template_func_illegal_call_target_end:
Index: tests/dynamic_code_loading/dynamic_modify_test.c
===================================================================
--- tests/dynamic_code_loading/dynamic_modify_test.c	(revision 3669)
+++ tests/dynamic_code_loading/dynamic_modify_test.c	(working copy)
@@ -14,7 +14,14 @@
 #include <sys/nacl_syscalls.h>
 
 #include "native_client/tests/dynamic_code_loading/templates.h"
+#include "native_client/tests/inbrowser_test_runner/test_runner.h"
 
+#if defined(__x86_64__)
+#define BUF_SIZE 64
+#else
+#define BUF_SIZE 32
+#endif
+
 #define NACL_BUNDLE_SIZE  32
 /*
  * TODO(bsy): get this value from the toolchain.  Get the toolchain
@@ -31,13 +38,33 @@
    nacl.scons, passed via --section-start. */
 #define DYNAMIC_CODE_SEGMENT_END 0x1000000
 
+struct code_section {
+  char *name;
+  char *start;
+  char *end;
+};
 
-char *next_addr = (char *) DYNAMIC_CODE_SEGMENT_START;
+struct code_section illegal_code_sections[] = {
+  { "misaligned_replacement",
+    &template_func_misaligned_replacement,
+    &template_func_misaligned_replacement_end },
+  { "illegal_register_replacement",
+    &template_func_illegal_register_replacement,
+    &template_func_illegal_register_replacement_end },
+  { "illegal_guard_replacement",
+    &template_func_illegal_guard_replacement,
+    &template_func_illegal_guard_replacement_end },
+  { "illegal_call_target",
+    &template_func_illegal_call_target,
+    &template_func_illegal_call_target_end },
+};
 
-char *allocate_code_space(int pages) {
-  char *addr = next_addr;
+uint8_t *next_addr = (uint8_t *) DYNAMIC_CODE_SEGMENT_START;
+
+uint8_t *allocate_code_space(int pages) {
+  uint8_t *addr = next_addr;
   next_addr += 0x10000 * pages;
-  assert(next_addr < (char *) DYNAMIC_CODE_SEGMENT_END);
+  assert(next_addr < (uint8_t *) DYNAMIC_CODE_SEGMENT_END);
   return addr;
 }
 
@@ -72,7 +99,7 @@
                            const char *fragment_end) {
   int fragment_size = fragment_end - fragment_start;
   assert(dest_size % 32 == 0);
-  assert(fragment_size < dest_size);
+  assert(fragment_size <= dest_size);
   fill_nops(dest, dest_size);
   memcpy(dest, fragment_start, fragment_size);
 }
@@ -80,7 +107,7 @@
 /* Check that we can't dynamically rewrite code. */
 void test_replacing_code() {
   uint8_t *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
   int (*func)();
 
@@ -105,7 +132,7 @@
 /* Check that we can dynamically rewrite code. */
 void test_replacing_code_unaligned() {
   uint8_t *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int first_diff = 0;
   int rc;
   int (*func)();
@@ -117,14 +144,13 @@
   rc = func();
   assert(rc == 1234);
 
-
   /* write replacement to the same location, unaligned */
   copy_and_pad_fragment(buf, sizeof(buf), &template_func_replacement,
                                           &template_func_replacement_end);
   while (buf[first_diff] == load_area[first_diff] && first_diff < sizeof buf) {
     first_diff++;
   }
-  assert(first_diff>0);
+  assert(first_diff>0 && first_diff<=sizeof(buf));
   rc = nacl_dyncode_modify(load_area+first_diff, buf+first_diff,
                            sizeof(buf)-first_diff);
   assert(rc == 0);
@@ -136,8 +162,7 @@
 /* Check that we can dynamically delete code. */
 void test_deleting_code() {
   uint8_t *load_area = allocate_code_space(1);
-  uint8_t buf[32];
-  int first_diff = 0;
+  uint8_t buf[BUF_SIZE];
   int rc;
   int (*func)();
 
@@ -153,11 +178,41 @@
   assert(load_area[0] != buf[0]);
 }
 
+/* Check code replacement constraints */
+void test_illegal_code_replacment() {
+  uint8_t *load_area = allocate_code_space(1);
+  uint8_t buf[BUF_SIZE];
+  int rc;
+  int i;
+  int (*func)();
 
+  copy_and_pad_fragment(buf, sizeof(buf), &template_func, &template_func_end);
+  rc = nacl_dyncode_create(load_area, buf, sizeof(buf));
+  assert(rc == 0);
+  func = (int (*)()) (uintptr_t) load_area;
+  rc = func();
+  assert(rc == 1234);
+
+  for (i = 0;
+       i < (sizeof(illegal_code_sections) / sizeof(struct code_section));
+       i++) {
+    printf("\t%s\n", illegal_code_sections[i].name);
+
+    /* write illegal replacement to the same location */
+    copy_and_pad_fragment(buf, sizeof(buf), illegal_code_sections[i].start,
+                                            illegal_code_sections[i].end);
+    rc = nacl_dyncode_modify(load_area, buf, sizeof(buf));
+    assert(rc != 0);
+    func = (int (*)()) (uintptr_t) load_area;
+    rc = func();
+    assert(rc == 1234);
+  }
+}
+
 /* Check that we can't dynamically rewrite code. */
 void test_replacing_code_disabled() {
   uint8_t *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int rc;
   int (*func)();
 
@@ -181,7 +236,7 @@
 /* Check that we can dynamically rewrite code. */
 void test_replacing_code_unaligned_disabled() {
   uint8_t *load_area = allocate_code_space(1);
-  uint8_t buf[32];
+  uint8_t buf[BUF_SIZE];
   int first_diff = 0;
   int rc;
   int (*func)();
@@ -211,8 +266,7 @@
 /* Check that we can't delete code */
 void test_deleting_code_disabled() {
   uint8_t *load_area = allocate_code_space(1);
-  uint8_t buf[32];
-  int first_diff = 0;
+  uint8_t buf[BUF_SIZE];
   int rc;
   int (*func)();
 
@@ -240,7 +294,7 @@
 
 #define RUN_TEST(test_func) (run_test(#test_func, test_func))
 
-int main() {
+int TestMain() {
   /* Turn off stdout buffering to aid debugging in case of a crash. */
   setvbuf(stdout, NULL, _IONBF, 0);
 
@@ -249,6 +303,7 @@
     RUN_TEST(test_replacing_code);
     RUN_TEST(test_replacing_code_unaligned);
     RUN_TEST(test_deleting_code);
+    RUN_TEST(test_illegal_code_replacment);
   } else {
     printf("Code replacement DISABLED\n");
     RUN_TEST(test_replacing_code_disabled);
@@ -259,3 +314,7 @@
   return 0;
 }
 
+int main() {
+  return RunTests(TestMain);
+}
+
Index: tests/dynamic_code_loading/templates_arm.S
===================================================================
--- tests/dynamic_code_loading/templates_arm.S	(revision 3669)
+++ tests/dynamic_code_loading/templates_arm.S	(working copy)
@@ -4,6 +4,26 @@
  * be found in the LICENSE file.
  */
 
+
+        .global template_func_misaligned_replacement
+        .global template_func_misaligned_replacement_end
+        .global template_func_illegal_call_target
+        .global template_func_illegal_call_target_end
+        .global template_func_illegal_register_replacement
+        .global template_func_illegal_register_replacement_end
+        .global template_func_illegal_guard_replacement
+        .global template_func_illegal_guard_replacement_end
+template_func_misaligned_replacement:
+template_func_illegal_call_target:
+template_func_illegal_register_replacement:
+template_func_illegal_guard_replacement
+        /* Not implemented */
+        bkpt 0x7777   /* hlt */
+template_func_misaligned_replacement_end:
+template_func_illegal_call_target_end:
+template_func_illegal_register_replacement_end:
+template_func_illegal_guard_replacement_end:
+
         .global template_func
         .global template_func_end
 template_func:
